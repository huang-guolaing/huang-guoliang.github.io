<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小黄笔记本</title>
  
  <subtitle>xh-notes</subtitle>
  <link href="https://huang-guoliang.github.io/atom.xml" rel="self"/>
  
  <link href="https://huang-guoliang.github.io/"/>
  <updated>2022-04-02T11:24:23.848Z</updated>
  <id>https://huang-guoliang.github.io/</id>
  
  <author>
    <name>Huang Guoliang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《贝叶斯思维》目录</title>
    <link href="https://huang-guoliang.github.io/posts/e918a543/"/>
    <id>https://huang-guoliang.github.io/posts/e918a543/</id>
    <published>2022-04-02T11:20:48.000Z</published>
    <updated>2022-04-02T11:24:23.848Z</updated>
    
    <content type="html"><![CDATA[<p>在线版本：<a href="https://allendowney.github.io/ThinkBayes2/">Think Bayes 2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在线版本：&lt;a href=&quot;https://allendowney.github.io/ThinkBayes2/&quot;&gt;Think Bayes 2&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Mathematics" scheme="https://huang-guoliang.github.io/categories/Mathematics/"/>
    
    <category term="Statistics" scheme="https://huang-guoliang.github.io/categories/Mathematics/Statistics/"/>
    
    <category term="think-bayes" scheme="https://huang-guoliang.github.io/categories/Mathematics/Statistics/think-bayes/"/>
    
    
    <category term="Stats" scheme="https://huang-guoliang.github.io/tags/Stats/"/>
    
    <category term="Bayes" scheme="https://huang-guoliang.github.io/tags/Bayes/"/>
    
  </entry>
  
  <entry>
    <title>通过Flask REST API部署PyTorch</title>
    <link href="https://huang-guoliang.github.io/posts/42477f40/"/>
    <id>https://huang-guoliang.github.io/posts/42477f40/</id>
    <published>2022-01-22T06:52:41.000Z</published>
    <updated>2022-01-22T09:08:27.721Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://pytorch.org/tutorials/intermediate/flask_rest_api_tutorial.html">Deploying PyTorch in Python via a REST API with Flask</a></p><blockquote><p>任务：部署一个预训练的DenseNet 121模型来检测图像。</p></blockquote><!-- toc --><ul><li><a href="#定义api接口">定义API接口</a></li><li><a href="#安装依赖">安装依赖</a></li><li><a href="#用flask写一个极简的web服务">用Flask写一个极简的Web服务</a></li><li><a href="#写一个推断模型">写一个推断模型</a><ul><li><a href="#处理图像">处理图像</a></li><li><a href="#预测">预测</a></li></ul></li><li><a href="#整合在一起">整合在一起</a></li><li><a href="#todo">TODO</a></li></ul><!-- tocstop --><h3><span id="定义api接口">定义API接口</span></h3><ul><li>API端点<code>/predict</code>接收POST请求</li><li>该请求<code>file</code>参数指定一个图像文件</li><li>返回的将是包含预测值的JSON响应：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;class_id&quot;</span>: <span class="string">&quot;n02124075&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;class_name&quot;</span>: <span class="string">&quot;Egyptian_cat&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="安装依赖">安装依赖</span></h3><p>可以先新建一个环境(省略)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install Flask==2.0.1 torchvision==0.10.0</span><br></pre></td></tr></table></figure></p><h3><span id="用flask写一个极简的web服务">用Flask写一个极简的Web服务</span></h3><p>参考Flask文档<a href="https://flask.palletsprojects.com/en/2.0.x/quickstart/#a-minimal-application">A Minimal Application</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><p>用开发模型来运行这个服务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ FLASK_ENV=development FLASK_APP=app.py flask run</span><br></pre></td></tr></table></figure><br>在浏览器访问<code>http://localhost:5000/</code>:<br><img src alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/predict&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>():</span></span><br><span class="line">    <span class="comment"># jsonify将数据序列化为JSON，并在响应中</span></span><br><span class="line">    <span class="comment"># 指定了application/json内容类型</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;class_id&quot;</span>: <span class="string">&quot;n02124075&quot;</span>,</span><br><span class="line">        <span class="string">&quot;class_name&quot;</span>: <span class="string">&quot;Egyptian_cat&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3><span id="写一个推断模型">写一个推断模型</span></h3><h4><span id="处理图像">处理图像</span></h4><ul><li>DenseNet模型要求图像为3通道RGB图像，大小为224x224</li><li>使用ImageNet设计的均值和标准差值对图像张量进行归一化</li><li>使用<code>torchvision</code>库中转换器<code>transforms</code>构建一个转换管道来处理图像</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trans.py</span></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform_image</span>(<span class="params">image_bytes</span>):</span></span><br><span class="line">    my_transforms = transforms.Compose(</span><br><span class="line">      [</span><br><span class="line">        transforms.Resize(size=<span class="number">255</span>),</span><br><span class="line">        transforms.CenterCrop(size=<span class="number">224</span>),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize(</span><br><span class="line">          mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">          std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">      ]</span><br><span class="line">    )</span><br><span class="line">    image = Image.<span class="built_in">open</span>(io.BytesIO(image_bytes))</span><br><span class="line">    <span class="keyword">return</span> my_transforms(image).unsqueeze(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;_static/img/cindy.jpg&quot;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        image_bytes = f.read()</span><br><span class="line">        tensor = transform_image(image_bytes=image_bytes)</span><br><span class="line">        <span class="built_in">print</span>(tensor)</span><br></pre></td></tr></table></figure><p>用一张图片测试一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ python trans.py </span><br><span class="line">tensor([[[[0.9474, 0.9474, 0.9646,  ..., 0.5878, 0.5878, 0.5707],</span><br><span class="line">          [0.9474, 0.9646, 0.9817,  ..., 0.5536, 0.5536, 0.5536],</span><br><span class="line">          [0.9474, 0.9817, 0.9817,  ..., 0.5193, 0.5193, 0.5022],</span><br><span class="line">          ...,</span><br><span class="line">          [1.6324, 1.6153, 1.5982,  ..., 2.0434, 2.0605, 2.0434],</span><br><span class="line">          [1.6324, 1.6153, 1.5982,  ..., 2.0434, 2.0434, 2.0434],</span><br><span class="line">          [1.6495, 1.6324, 1.6153,  ..., 2.0263, 2.0263, 2.0263]],</span><br><span class="line"></span><br><span class="line">         [[1.0280, 1.0455, 1.0630,  ..., 1.0280, 1.0280, 1.0105],</span><br><span class="line">          [1.0280, 1.0455, 1.0805,  ..., 0.9930, 0.9930, 0.9930],</span><br><span class="line">          [1.0280, 1.0630, 1.0805,  ..., 0.9580, 0.9580, 0.9405],</span><br><span class="line">          ...,</span><br><span class="line">          [1.7808, 1.7808, 1.7808,  ..., 2.1485, 2.1660, 2.1485],</span><br><span class="line">          [1.7808, 1.7808, 1.7808,  ..., 2.1485, 2.1485, 2.1485],</span><br><span class="line">          [1.7983, 1.7983, 1.7983,  ..., 2.1310, 2.1310, 2.1310]],</span><br><span class="line"></span><br><span class="line">         [[1.1934, 1.1934, 1.1934,  ..., 1.0714, 1.0714, 1.0539],</span><br><span class="line">          [1.1934, 1.1934, 1.1934,  ..., 1.0365, 1.0365, 1.0365],</span><br><span class="line">          [1.2108, 1.2108, 1.1759,  ..., 1.0017, 1.0017, 0.9842],</span><br><span class="line">          ...,</span><br><span class="line">          [1.9254, 1.9254, 1.9080,  ..., 2.3088, 2.3263, 2.3088],</span><br><span class="line">          [1.9254, 1.9254, 1.9080,  ..., 2.3088, 2.3088, 2.3088],</span><br><span class="line">          [1.9428, 1.9428, 1.9254,  ..., 2.2914, 2.2914, 2.2914]]]])</span><br><span class="line">torch.Size([1, 3, 224, 224])</span><br></pre></td></tr></table></figure></p><h4><span id="预测">预测</span></h4><ul><li>使用<code>torchvision</code>库的DenseNet 121<strong>预训练模型</strong>来预测图像的类别</li><li>预测结果包含预测类id的索引，但最终要返回一个类别名称</li><li>下载包含了ImageNet的类别id到类别名称的映射的JSON文件：<a href="https://s3.amazonaws.com/deep-learning-models/image-models/imagenet_class_index.json">imagenet_class_index</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># predict.py</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> trans <span class="keyword">import</span> transform_image</span><br><span class="line"></span><br><span class="line">imagenet_class_index = json.load(</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&#x27;_static/imagenet_class_index.json&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">model = models.densenet121(pretrained=<span class="literal">True</span>)</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_prediction</span>(<span class="params">image_bytes</span>):</span></span><br><span class="line">    tensor = transform_image(image_bytes=image_bytes)</span><br><span class="line">    outputs = model.forward(tensor)</span><br><span class="line">    _, y_hat = outputs.<span class="built_in">max</span>(<span class="number">1</span>)</span><br><span class="line">    predicted_idx = <span class="built_in">str</span>(y_hat.item())</span><br><span class="line">    <span class="keyword">return</span> imagenet_class_index[predicted_idx]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;_static/img/cindy.jpg&quot;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        image_bytes = f.read()</span><br><span class="line">        <span class="built_in">print</span>(get_prediction(image_bytes=image_bytes))</span><br></pre></td></tr></table></figure><p>模型变量<code>model</code>是全局变量而不是<code>get_prediction</code>方法的一部分：</p><ul><li>对于内存和计算而言，加载模型是一项昂贵的操作。</li><li>若在<code>get_prediction</code>方法中加载模型，那么每次调用该方法时都会不必要地加载它。</li><li>一个Web服务器每秒可能接收数千个请求，不应该浪费时间为每次推理冗余加载模型。因此，只将模型加载到内存中一次</li><li>在生产系统中必须高效使用算力才能大规模地服务请求，因此通常应该在服务请求之前加载模型</li></ul><p>那我家的喵咪来测试一下：<br><img src="cindy.jpg" alt="我家的Cindy喵"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python predict.py</span><br><span class="line">[<span class="string">&#x27;n02123394&#x27;</span>, <span class="string">&#x27;Persian_cat&#x27;</span>]</span><br></pre></td></tr></table></figure><h3><span id="整合在一起">整合在一起</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"><span class="keyword">from</span> predict <span class="keyword">import</span> get_prediction</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/predict&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>():</span></span><br><span class="line">  <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">    file = request.files[<span class="string">&#x27;file&#x27;</span>]</span><br><span class="line">    image_bytes = file.read()</span><br><span class="line">    class_id, class_name = get_prediction(</span><br><span class="line">      image_bytes=image_bytes)</span><br><span class="line">    <span class="keyword">return</span> jsonify(</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&#x27;class_id&#x27;</span>: class_id,</span><br><span class="line">        <span class="string">&#x27;class_name&#x27;</span>: class_name</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  app.run()</span><br></pre></td></tr></table></figure><p>写一个测试脚本，看看能不能辨别我家小狗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">resp = requests.post(</span><br><span class="line">    url=<span class="string">&quot;http://localhost:5000/predict&quot;</span>,</span><br><span class="line">    files=&#123;</span><br><span class="line">        <span class="string">&quot;file&quot;</span>: <span class="built_in">open</span>(<span class="string">&quot;_static/img/almond.jpg&quot;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(resp.json())</span><br></pre></td></tr></table></figure><p><img src="almond.jpg" alt="我家的杏仁狗"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行Flask</span></span><br><span class="line">$ FLASK_ENV=development FLASK_APP=app.py flask run</span><br><span class="line">$ python test.py</span><br><span class="line">&#123;<span class="string">&#x27;class_id&#x27;</span>: <span class="string">&#x27;n02086910&#x27;</span>, <span class="string">&#x27;class_name&#x27;</span>: <span class="string">&#x27;papillon&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>┗|｀O′|┛咩啊！我家的杏仁是边牧啦！</p><h3><span id="todo">TODO</span></h3><ul><li>换个模型？</li><li>加点UI？</li><li>生产部署？</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文链接：&lt;a href=&quot;https://pytorch.org/tutorials/intermediate/flask_rest_api_tutorial.html&quot;&gt;Deploying PyTorch in Python via a REST API with Fl</summary>
      
    
    
    
    <category term="Tools" scheme="https://huang-guoliang.github.io/categories/Tools/"/>
    
    <category term="PyTorch" scheme="https://huang-guoliang.github.io/categories/Tools/PyTorch/"/>
    
    
    <category term="PyTorch" scheme="https://huang-guoliang.github.io/tags/PyTorch/"/>
    
    <category term="Flask" scheme="https://huang-guoliang.github.io/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>seaborn教程02-seaborn支持的数据格式</title>
    <link href="https://huang-guoliang.github.io/posts/46da756c/"/>
    <id>https://huang-guoliang.github.io/posts/46da756c/</id>
    <published>2022-01-20T09:01:36.000Z</published>
    <updated>2022-01-22T06:50:44.965Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sns.__version__</span><br><span class="line"><span class="string">&#x27;0.11.2&#x27;</span></span><br></pre></td></tr></table></figure><h3><span id="长格式数据long-form-data">长格式数据(Long-form data)</span></h3><p>一个长格式数据的表格具有以下特征：</p><ul><li>一列代表一个变量</li><li>一行代表一个观测结果(样本)</li></ul><p>以航班(flights)数据集为例，它记录了从1949年到1960年每个月乘坐飞机的乘客数量。该数据集有三个变量(年、月和乘客数量):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>flights = sns.load_dataset(<span class="string">&quot;flights&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flights.head()</span><br><span class="line">   year month  passengers</span><br><span class="line"><span class="number">0</span>  <span class="number">1949</span>   Jan         <span class="number">112</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1949</span>   Feb         <span class="number">118</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1949</span>   Mar         <span class="number">132</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1949</span>   Apr         <span class="number">129</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1949</span>   May         <span class="number">121</span></span><br></pre></td></tr></table></figure><p>对于长格式数据，通过将表中的列显式分配给一个变量，就可以为它们在图中赋予角色。<br>例如，制作每年乘客数量的月度图：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plot_long_form = sns.relplot(</span><br><span class="line">  data=flights,</span><br><span class="line">  x=<span class="string">&quot;year&quot;</span>,</span><br><span class="line">  y=<span class="string">&quot;passengers&quot;</span>,</span><br><span class="line">  hue=<span class="string">&quot;month&quot;</span>,</span><br><span class="line">  kind=<span class="string">&quot;line&quot;</span></span><br><span class="line">)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="long_form.png" alt="长格式数据绘出的每年乘客数量的月度图"></p><h3><span id="宽格式数据wide-form-data">宽格式数据(Wide-form data)</span></h3><p>一些简单的数据集采用宽格式，列和行包含不同变量的级别。<br>通过“透视”的方式将航班数据集转换为宽格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>flights_wide = flights.pivot(</span><br><span class="line"><span class="meta">... </span>  index=<span class="string">&quot;year&quot;</span>,</span><br><span class="line"><span class="meta">... </span>  columns=<span class="string">&quot;month&quot;</span>,</span><br><span class="line"><span class="meta">... </span>  values=<span class="string">&quot;passengers&quot;</span></span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flights_wide.head()</span><br><span class="line">month  Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec</span><br><span class="line">year</span><br><span class="line"><span class="number">1949</span>   <span class="number">112</span>  <span class="number">118</span>  <span class="number">132</span>  <span class="number">129</span>  <span class="number">121</span>  <span class="number">135</span>  <span class="number">148</span>  <span class="number">148</span>  <span class="number">136</span>  <span class="number">119</span>  <span class="number">104</span>  <span class="number">118</span></span><br><span class="line"><span class="number">1950</span>   <span class="number">115</span>  <span class="number">126</span>  <span class="number">141</span>  <span class="number">135</span>  <span class="number">125</span>  <span class="number">149</span>  <span class="number">170</span>  <span class="number">170</span>  <span class="number">158</span>  <span class="number">133</span>  <span class="number">114</span>  <span class="number">140</span></span><br><span class="line"><span class="number">1951</span>   <span class="number">145</span>  <span class="number">150</span>  <span class="number">178</span>  <span class="number">163</span>  <span class="number">172</span>  <span class="number">178</span>  <span class="number">199</span>  <span class="number">199</span>  <span class="number">184</span>  <span class="number">162</span>  <span class="number">146</span>  <span class="number">166</span></span><br><span class="line"><span class="number">1952</span>   <span class="number">171</span>  <span class="number">180</span>  <span class="number">193</span>  <span class="number">181</span>  <span class="number">183</span>  <span class="number">218</span>  <span class="number">230</span>  <span class="number">242</span>  <span class="number">209</span>  <span class="number">191</span>  <span class="number">172</span>  <span class="number">194</span></span><br><span class="line"><span class="number">1953</span>   <span class="number">196</span>  <span class="number">196</span>  <span class="number">236</span>  <span class="number">235</span>  <span class="number">229</span>  <span class="number">243</span>  <span class="number">264</span>  <span class="number">272</span>  <span class="number">237</span>  <span class="number">211</span>  <span class="number">180</span>  <span class="number">201</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>plot_wide_form = sns.relplot(</span><br><span class="line"><span class="meta">... </span>  data=flights_wide,</span><br><span class="line"><span class="meta">... </span>  kind=<span class="string">&quot;line&quot;</span></span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.show()</span><br></pre></td></tr></table></figure><p><img src="wide_form.png" alt="宽格式数据绘出的每年乘客数量的月度图"></p><p>这个图与上一个图看似相似，但有明显的不同。<br>Seaborn将<code>DataFrame</code>的索引<code>year</code>分配给<code>x</code>，将<code>DataFrame</code>的值分配给<code>y</code>，为每个月绘制了一条单独的线。<br>当数据集通过<code>pivot</code>操作将其从长格式转换为宽格式时，乘客数量(passengers)的含义信息就丢失了。<br>因此，图中没有y轴标签。(这些线在这里也有破折号，因为<code>relplot()</code>将列变量映射为颜色和样式语义，以便更容易访问plot。在长格式的情况下我们没有这样做，但是我们可以通过设置style=”month”来实现)。</p><h3><span id="宽格式数据可视化的选项">宽格式数据可视化的选项</span></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="Tools" scheme="https://huang-guoliang.github.io/categories/Tools/"/>
    
    <category term="seaborn" scheme="https://huang-guoliang.github.io/categories/Tools/seaborn/"/>
    
    
    <category term="seaborn" scheme="https://huang-guoliang.github.io/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>分子的机器学习描述符</title>
    <link href="https://huang-guoliang.github.io/posts/68090c70/"/>
    <id>https://huang-guoliang.github.io/posts/68090c70/</id>
    <published>2022-01-19T00:49:44.000Z</published>
    <updated>2022-01-20T07:44:14.084Z</updated>
    
    <content type="html"><![CDATA[<p>文章链接：<a href="https://chemintelligence.com/blog/machine-learning-descriptors-molecules">Machine learning descriptors for molecules</a></p><!-- toc --><ul><li><a href="#适用于机器学习的描述符有哪些特点">适用于机器学习的描述符有哪些特点？</a></li><li><a href="#描述符有哪些类型">描述符有哪些类型？</a></li><li><a href="#如何选择描述符组合">如何选择描述符(组合)？</a></li><li><a href="#总结">总结</a></li><li><a href="#参考资料">参考资料</a></li></ul><!-- tocstop --><p>在预测分子性质时，分子结构在被用来训练机器学习模型之前被转换成描述符(descriptors)。</p><p><img src="workflow.jpg" alt="基于机器学习的分子性能预测的典型工作流程&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;"></p><p>本文的目的是概述分子描述符，并讨论三个主要问题:</p><h3><span id="适用于机器学习的描述符有哪些特点">适用于机器学习的描述符有哪些特点？</span></h3><p>选用一个满足以下三个标准的描述符来编码你的分子：</p><ol><li>描述符与将要预测的分子性质有较高相关度；</li><li>不同的分子结构对应的描述符有不同的值(或表示)；</li><li>根据分子的大小来匹配合适的描述符(不是所有的描述符都适合所有大小的分子)。</li></ol><p>针对具体的机器学习任务，描述符还需要遵循其他一些标准，例如：</p><ul><li>能区分同分异构体；</li><li>可解码(从描述符返回到分子结构)；</li><li>数据量与描述符的维度(通常，数据集中的分子数量应远大于描述符的维数)。</li></ul><h3><span id="描述符有哪些类型">描述符有哪些类型？</span></h3><p>分子描述符分为两类：实验性的描述符和理论性的描述符。</p><ul><li><strong><em>实验性的描述符(Experimental)</em></strong><br><strong>实验测量或理论计算</strong>得到的物理化学性质。</li><li><strong><em>理论性的描述符(Theoretical)</em></strong><br>来自于<strong>分子的符号表示</strong>。根据”维度“又可分为以下五类:<ul><li><strong><em>0维(0D)描述符</em></strong><ul><li><strong>不提供</strong>任何有关<strong>分子结构或原子连通性信息</strong>的分子描述符。</li><li>例如，原子数、键数或分子量都是0D描述符。</li><li>它们的优点是很容易获得，但要与其他描述符组合使用；</li></ul></li><li><strong><em>1维(1D)描述符</em></strong><ul><li>由<strong>一组子结构</strong>(如官能团)<strong>计算</strong>得到的描述符。</li><li>其优点也是容易获得。</li><li>分子指纹就是一类最常见的1D描述符。</li></ul></li><li><strong><em>2维(2D)描述符</em></strong><ul><li>通过分子的<strong>图表示(graph representation)</strong>获得分子<strong>拓扑信息</strong>的描述符。</li><li>典型的2D描述符是<br>邻接矩阵(Adjacency matrix)，<br>库仑矩阵(Coulomb matrix)和<br>距离矩阵(Distance matrix)。</li><li>由于2D描述符对分子的结构特征(大小、形状和对称性)很敏感，因此它们是常用的一类描述符。</li></ul></li><li><strong><em>3维(3D)描述符</em></strong><ul><li>提供有关分子原子空间<strong>坐标信息</strong>的几何描述符。</li><li>最著名的3D描述符是<br>分子矩阵(Molecular matrix)和<br>3D-MoRSE描述符。</li><li>由于几何描述符的复杂性，其计算十分耗时。</li></ul></li><li><strong><em>4维(4D)描述符</em></strong>：<ul><li>也被称为“基于<strong>网格</strong>的描述符”。这类描述符除了分子几何外，还引入了第四维空间。</li><li>这个新维度通常表征分子与受体活性位点之间的相互作用或分子的多重构象状态。</li><li>常用的4D描述符有CoMFA和GRID。</li><li>一个优点是，它们提供了比其他描述符更多的信息，并且总是能够为结构不同的分子生成不同的值。</li><li>然而，如同3D描述符一样，4D描述符因其高复杂性而难以获得。</li></ul></li></ul></li></ul><p><img src="theoretical_descriptors.bmp" alt="图示五类理论性的描述符(以布洛芬为例)&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;"></p><h3><span id="如何选择描述符组合">如何选择描述符(组合)？</span></h3><ul><li>从海量描述符中选择合适的描述符(组合)是一项非常困难的任务。</li><li>主要有两种选择策略：穷举搜索和优化算法。<ul><li><strong><em>穷举搜索(Exhaustive search)</em></strong><ul><li>也就是<strong>全子集</strong>模型(All Subset Model, ASM)。</li><li>N个描述符就有2<sup>N-1</sup>种组合。</li><li>此策略理论上能找到最优的描述符组合，但描述符数量过大时极为消耗算力，</li><li>比较适合只考虑少量描述符的情况。</li></ul></li><li><strong><em>优化算法(Optimization algorithms)</em></strong><ul><li>是通过<strong>迭代</strong>方法找出能使预测模型结果最优的描述符组合。</li><li>比较常用的算法有<br>进化规划(Evolutionary Programming，EP)，<br>蚁群优化(Ant Colony Optimization，ACO)，<br>顺序查找(Sequential Search，SS)和<br>遗传算法(Genetic Algorithms，GAs)。</li><li>一般的优化流程如下图所示：</li></ul></li></ul></li></ul><div id="flowchart-0" class="flow-chart"></div><h3><span id="总结">总结</span></h3><ul><li>分子用描述符表示后，可作为机器学习模型的特征输入。</li><li>描述符的选择很重要，因为它对模型的预测性能有很大的影响。</li><li>在选择描述符时，有四个关注点：<ul><li>描述符与预测性质之间的相关性</li><li>描述符为结构不同的分子生成不同值的能力</li><li>描述符的维数</li><li>可用的数据量</li></ul></li><li>描述符不能完全描述分子的结构复杂性，可通过使用高维描述符或多个描述符部分地解决。</li><li>使用高维描述符或描述符组合会增加模型的复杂度而降低算法的性能。</li></ul><h3><span id="参考资料">参考资料</span></h3><div><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始优化op1=>operation: 候选的描述符集合op2=>operation: 描述符子集cond=>condition: 预测模型评估e=>end: 最优的描述符子集    st->op1->op2(right)->condcond(no)->op1cond(yes)->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.sciencedirect.com/science/article/pii/S0010465519303042">DScribe: Library of descriptors for machine learning in materials science</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://link.springer.com/protocol/10.1007/978-1-4939-7899-1_1">Molecular descriptors for structure–activity applications: a hands-on approach</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章链接：&lt;a href=&quot;https://chemintelligence.com/blog/machine-learning-descriptors-molecules&quot;&gt;Machine learning descriptors for molecules&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    <category term="Cheminformatics" scheme="https://huang-guoliang.github.io/categories/Cheminformatics/"/>
    
    
    <category term="ML" scheme="https://huang-guoliang.github.io/tags/ML/"/>
    
    <category term="Descriptor" scheme="https://huang-guoliang.github.io/tags/Descriptor/"/>
    
  </entry>
  
  <entry>
    <title>seaborn教程01</title>
    <link href="https://huang-guoliang.github.io/posts/bc466d5/"/>
    <id>https://huang-guoliang.github.io/posts/bc466d5/</id>
    <published>2022-01-18T07:26:43.000Z</published>
    <updated>2022-01-20T08:31:48.208Z</updated>
    
    
    
    
    <category term="Tools" scheme="https://huang-guoliang.github.io/categories/Tools/"/>
    
    <category term="seaborn" scheme="https://huang-guoliang.github.io/categories/Tools/seaborn/"/>
    
    
  </entry>
  
  <entry>
    <title>《深度学习在分子与材料中的应用》导览</title>
    <link href="https://huang-guoliang.github.io/posts/f25b25e8/"/>
    <id>https://huang-guoliang.github.io/posts/f25b25e8/</id>
    <published>2022-01-18T06:19:04.000Z</published>
    <updated>2022-01-19T00:55:57.579Z</updated>
    
    
    
    
    <category term="Cheminformatics" scheme="https://huang-guoliang.github.io/categories/Cheminformatics/"/>
    
    <category term="dl4mm" scheme="https://huang-guoliang.github.io/categories/Cheminformatics/dl4mm/"/>
    
    
  </entry>
  
  <entry>
    <title>seaborn教程导览</title>
    <link href="https://huang-guoliang.github.io/posts/a1871603/"/>
    <id>https://huang-guoliang.github.io/posts/a1871603/</id>
    <published>2022-01-18T02:21:56.000Z</published>
    <updated>2022-01-19T09:48:06.015Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#教程目录">教程目录</a></li><li><a href="#安装seaborn">安装seaborn</a></li><li><a href="#小试牛刀">小试牛刀</a></li></ul><!-- tocstop --><blockquote><p><a href="https://seaborn.pydata.org">Seaborn</a>是一个用Python制作统计图形的库。<br>它构建在matplotlib之上，并与pandas数据结构紧密集成。<br>它为绘制出吸引注意且信息丰富的统计图形提供了高级接口。</p></blockquote><h3><span id="教程目录">教程目录</span></h3><ul><li>API overview<ul><li><a href="../bc466d5">Overview of seaborn plotting functions</a></li><li><a href>Data structures accepted by seaborn</a></li></ul></li><li>Plotting functions<ul><li><a href>Visualizing statistical relationships</a></li><li><a href>Visualizing distributions of data</a></li><li><a href>Plotting with categorical data</a></li><li><a href>Visualizing regression models</a></li></ul></li><li>Multi-plot grids<ul><li><a href>Building structured multi-plot grids</a></li></ul></li><li>Plot aesthetics<ul><li><a href>Controlling figure aesthetics</a></li><li><a href>Choosing color palettes</a></li></ul></li></ul><h3><span id="安装seaborn">安装seaborn</span></h3><p>通过PyPI或Anaconda直接安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip安装</span></span><br><span class="line">pip install seaborn</span><br><span class="line"><span class="comment"># 或conda安装</span></span><br><span class="line">conda install seaborn</span><br></pre></td></tr></table></figure><h3><span id="小试牛刀">小试牛刀</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入seaborn库</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="comment"># seaborn自带的示例数据集，</span></span><br><span class="line"><span class="comment"># 是pandas的DataFrame格式的</span></span><br><span class="line">df = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line"><span class="comment"># 如果在Jupyter Notebook上运行，</span></span><br><span class="line"><span class="comment"># 可以直接显示出图片</span></span><br><span class="line">plot = sns.pairplot(data=df, hue=<span class="string">&quot;species&quot;</span>)</span><br><span class="line"><span class="comment"># 保存图片</span></span><br><span class="line">plot.figure.savefig(<span class="string">&quot;out.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在非Jupyter Notebook环境中，</span></span><br><span class="line"><span class="comment"># 在窗口中显示图片需要matplotlib的帮助</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>轻松绘制出漂亮的图表：</p><p><img src="seaborn_quick_start.png" alt="seaborn绘图示例"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#教程目录&quot;&gt;教程目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#安装seaborn&quot;&gt;安装seaborn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#小试牛刀&quot;&gt;小试牛刀&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!--</summary>
      
    
    
    
    <category term="Tools" scheme="https://huang-guoliang.github.io/categories/Tools/"/>
    
    <category term="seaborn" scheme="https://huang-guoliang.github.io/categories/Tools/seaborn/"/>
    
    
    <category term="seaborn" scheme="https://huang-guoliang.github.io/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>《赤裸的统计学》第2章</title>
    <link href="https://huang-guoliang.github.io/posts/dac470bb/"/>
    <id>https://huang-guoliang.github.io/posts/dac470bb/</id>
    <published>2022-01-17T06:14:39.000Z</published>
    <updated>2022-01-19T00:55:26.152Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="chapter-2-descriptive-statistics-who-was-the-best-baseball-player-of-all-time">CHAPTER 2. Descriptive Statistics: Who was the best baseball player of all time?</span></h2><ul><li>要点：<ul><li>平均数容易受到远离[中心区域的“异常值”的干扰而出现失真。</li><li>标准差用于衡量数据相对于平均值的分散程度。</li></ul></li></ul><style>  .article-entry table { width: 50%; }  table th { width: 30px; }</style><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">&gt;10</th></tr></thead><tbody><tr><td style="text-align:center">competitor</td><td style="text-align:center">12</td><td style="text-align:center">14</td><td style="text-align:center">36</td><td style="text-align:center">13</td><td style="text-align:center">8</td><td style="text-align:center">6</td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">your</td><td style="text-align:center">25</td><td style="text-align:center">31</td><td style="text-align:center">9</td><td style="text-align:center">4</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">26</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">compet = [<span class="number">12</span>, <span class="number">14</span>, <span class="number">36</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">your = [<span class="number">25</span>, <span class="number">31</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">26</span>]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;chapter-2-descriptive-statistics-who-was-the-best-baseball-player-of-all-time&quot;&gt;CHAPTER 2. Descriptive Statistics: Who was the </summary>
      
    
    
    
    <category term="Mathematics" scheme="https://huang-guoliang.github.io/categories/Mathematics/"/>
    
    <category term="Statistics" scheme="https://huang-guoliang.github.io/categories/Mathematics/Statistics/"/>
    
    <category term="naked-stats" scheme="https://huang-guoliang.github.io/categories/Mathematics/Statistics/naked-stats/"/>
    
    
    <category term="Stats" scheme="https://huang-guoliang.github.io/tags/Stats/"/>
    
  </entry>
  
  <entry>
    <title>《赤裸的统计学》第1章</title>
    <link href="https://huang-guoliang.github.io/posts/e1f2a54d/"/>
    <id>https://huang-guoliang.github.io/posts/e1f2a54d/</id>
    <published>2022-01-17T02:52:26.000Z</published>
    <updated>2022-01-19T00:55:12.816Z</updated>
    
    
    
    
    <category term="Mathematics" scheme="https://huang-guoliang.github.io/categories/Mathematics/"/>
    
    <category term="Statistics" scheme="https://huang-guoliang.github.io/categories/Mathematics/Statistics/"/>
    
    <category term="naked-stats" scheme="https://huang-guoliang.github.io/categories/Mathematics/Statistics/naked-stats/"/>
    
    
    <category term="Stats" scheme="https://huang-guoliang.github.io/tags/Stats/"/>
    
  </entry>
  
  <entry>
    <title>《赤裸的统计学》目录</title>
    <link href="https://huang-guoliang.github.io/posts/54daf226/"/>
    <id>https://huang-guoliang.github.io/posts/54daf226/</id>
    <published>2022-01-17T02:42:23.000Z</published>
    <updated>2022-01-19T00:54:59.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>英文原版：<a href="https://book.douban.com/subject/19941764/">Naked Statistics</a><br>中文译版：<a href="https://book.douban.com/subject/25717380/">赤裸的统计学</a></p></blockquote><ul><li><strong><em>Introduction: Why I hated calculus but love statistics</em></strong></li><li><a href="../e1f2a54d"><strong><em>Chapter 01. What’s the Point?</em></strong></a></li><li><a href><strong><em>Chapter 02. Descriptive Statistics</em></strong></a></li><li><a href><strong><em>Chapter 03. Deceptive Description</em></strong></a></li><li><a href><strong><em>Chapter 04. Correlation</em></strong></a></li><li><a href><strong><em>Chapter 05. Basic Probability</em></strong></a></li><li><a href><strong><em>Chapter 05½. The Monty Hall Problem</em></strong></a></li><li><a href><strong><em>Chapter 06. Probems with Probaility</em></strong></a></li><li><a href><strong><em>Chapter 07. The Importance of Data</em></strong></a></li><li><a href><strong><em>Chapter 08. The Central Limit Theorm</em></strong></a></li><li><a href><strong><em>Chapter 09. Inference</em></strong></a></li><li><a href><strong><em>Chapter 10. Polling</em></strong></a></li><li><a href><strong><em>Chapter 11. Regression Analysis</em></strong></a></li><li><a href><strong><em>Chapter 12. Common Regression Mistakes</em></strong></a></li><li><a href><strong><em>Chapter 13. Program Evaluations</em></strong></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;英文原版：&lt;a href=&quot;https://book.douban.com/subject/19941764/&quot;&gt;Naked Statistics&lt;/a&gt;&lt;br&gt;中文译版：&lt;a href=&quot;https://book.douban.com/subje</summary>
      
    
    
    
    <category term="Mathematics" scheme="https://huang-guoliang.github.io/categories/Mathematics/"/>
    
    <category term="Statistics" scheme="https://huang-guoliang.github.io/categories/Mathematics/Statistics/"/>
    
    <category term="naked-stats" scheme="https://huang-guoliang.github.io/categories/Mathematics/Statistics/naked-stats/"/>
    
    
    <category term="Stats" scheme="https://huang-guoliang.github.io/tags/Stats/"/>
    
  </entry>
  
  <entry>
    <title>——欢迎光临我的博客——</title>
    <link href="https://huang-guoliang.github.io/posts/55bc8bfb/"/>
    <id>https://huang-guoliang.github.io/posts/55bc8bfb/</id>
    <published>2022-01-15T08:18:40.000Z</published>
    <updated>2022-04-02T11:28:01.316Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我是 <del>老黄</del> 小黄，一名本硕 光学专业 在 化工行业 打滚的 IT 工程师。<br>现在主攻 机器学习 和 化学信息学。<br>给我发信息：xh-notes@foxmail.com</p></blockquote><p><strong><em>课程：</em></strong></p><ul><li><strong><em>Dive into Deep Learning</em></strong>　<a href="http://www.d2l.ai/">[课程地址]</a> <a href="https://space.bilibili.com/1567748478/channel/seriesdetail?sid=358497">[视频地址]</a> <a href>[我的笔记]</a></li></ul><p><strong><em>教程：</em></strong></p><ul><li><strong><em>Seaborn Tutorial</em></strong>　<a href="posts/a1871603">[我的笔记]</a></li></ul><p><strong><em>书单：</em></strong></p><ul><li><strong><em>Think Bayes; Allen B. Downey; 2021.</em></strong><a href="https://allendowney.github.io/ThinkBayes2/">[在线阅读]</a> <a href="posts/e918a543">[我的笔记]</a></li><li><strong><em>Deep Learning for Molecules and Materials; Andrew D. White; 2021.　</em></strong><a href="https://dmol.pub">[在线阅读]</a> <a href="posts/f25b25e8">[我的笔记]</a></li><li><strong><em>Deep Learning from Scratch; Seth Weidman; O’Reilly Media, Inc.; 2019.</em></strong>　<a href>[我的笔记]</a></li><li><strong><em>Naked Statistics; Charles Wheelan; W. W. Norton &amp; Company, Inc.; 2013.</em></strong>　<a href="posts/54daf226">[我的笔记]</a></li></ul><p><strong><em>文章：</em></strong></p><ul><li><strong><em>Machine learning descriptors for molecules; chemintelligence.com; 2021.</em></strong>　<a href="posts/68090c70">[我的笔记]</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我是 &lt;del&gt;老黄&lt;/del&gt; 小黄，一名本硕 光学专业 在 化工行业 打滚的 IT 工程师。&lt;br&gt;现在主攻 机器学习 和 化学信息学。&lt;br&gt;给我发信息：xh-notes@foxmail.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;s</summary>
      
    
    
    
    
  </entry>
  
</feed>
