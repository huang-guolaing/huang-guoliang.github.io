{"meta":{"title":"小黄笔记本","subtitle":"xh-notes","description":"","author":"Huang Guoliang","url":"https://huang-guoliang.github.io","root":"/"},"pages":[{"title":"About","date":"2022-01-15T07:48:36.925Z","updated":"2022-01-15T07:48:36.925Z","comments":true,"path":"about/index.html","permalink":"https://huang-guoliang.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2022-01-15T07:48:36.925Z","updated":"2022-01-15T07:48:36.925Z","comments":true,"path":"categories/index.html","permalink":"https://huang-guoliang.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2022-01-17T05:40:30.705Z","updated":"2022-01-17T05:40:30.705Z","comments":true,"path":"tags/index.html","permalink":"https://huang-guoliang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"通过Flask REST API部署PyTorch","slug":"Tools/PyTorch/deploy-pytorch-with-flask","date":"2022-01-22T06:52:41.000Z","updated":"2022-01-22T09:08:27.721Z","comments":true,"path":"posts/42477f40/","link":"","permalink":"https://huang-guoliang.github.io/posts/42477f40/","excerpt":"","text":"原文链接：Deploying PyTorch in Python via a REST API with Flask 任务：部署一个预训练的DenseNet 121模型来检测图像。 定义API接口 安装依赖 用Flask写一个极简的Web服务 写一个推断模型 处理图像 预测 整合在一起 TODO 定义API接口 API端点/predict接收POST请求 该请求file参数指定一个图像文件 返回的将是包含预测值的JSON响应：1234&#123; &quot;class_id&quot;: &quot;n02124075&quot;, &quot;class_name&quot;: &quot;Egyptian_cat&quot;&#125; 安装依赖可以先新建一个环境(省略)1$ pip install Flask==2.0.1 torchvision==0.10.0 用Flask写一个极简的Web服务参考Flask文档A Minimal Application 12345678# app.pyfrom flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def hello(): return &quot;Hello!&quot; 用开发模型来运行这个服务:1$ FLASK_ENV=development FLASK_APP=app.py flask run在浏览器访问http://localhost:5000/: 1234567891011121314# app.pyfrom flask import Flask, jsonifyapp = Flask(__name__)@app.route(&quot;/predict&quot;, methods=[&quot;POST&quot;])def predict(): # jsonify将数据序列化为JSON，并在响应中 # 指定了application/json内容类型 return jsonify( &#123; &quot;class_id&quot;: &quot;n02124075&quot;, &quot;class_name&quot;: &quot;Egyptian_cat&quot; ) 写一个推断模型处理图像 DenseNet模型要求图像为3通道RGB图像，大小为224x224 使用ImageNet设计的均值和标准差值对图像张量进行归一化 使用torchvision库中转换器transforms构建一个转换管道来处理图像 123456789101112131415161718192021222324# trans.pyimport ioimport torchvision.transforms as transformsfrom PIL import Imagedef transform_image(image_bytes): my_transforms = transforms.Compose( [ transforms.Resize(size=255), transforms.CenterCrop(size=224), transforms.ToTensor(), transforms.Normalize( mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]) ] ) image = Image.open(io.BytesIO(image_bytes)) return my_transforms(image).unsqueeze(0)if __name__ == &#x27;__main__&#x27;: with open(&quot;_static/img/cindy.jpg&quot;, &#x27;rb&#x27;) as f: image_bytes = f.read() tensor = transform_image(image_bytes=image_bytes) print(tensor) 用一张图片测试一下：12345678910111213141516171819202122232425$ python trans.py tensor([[[[0.9474, 0.9474, 0.9646, ..., 0.5878, 0.5878, 0.5707], [0.9474, 0.9646, 0.9817, ..., 0.5536, 0.5536, 0.5536], [0.9474, 0.9817, 0.9817, ..., 0.5193, 0.5193, 0.5022], ..., [1.6324, 1.6153, 1.5982, ..., 2.0434, 2.0605, 2.0434], [1.6324, 1.6153, 1.5982, ..., 2.0434, 2.0434, 2.0434], [1.6495, 1.6324, 1.6153, ..., 2.0263, 2.0263, 2.0263]], [[1.0280, 1.0455, 1.0630, ..., 1.0280, 1.0280, 1.0105], [1.0280, 1.0455, 1.0805, ..., 0.9930, 0.9930, 0.9930], [1.0280, 1.0630, 1.0805, ..., 0.9580, 0.9580, 0.9405], ..., [1.7808, 1.7808, 1.7808, ..., 2.1485, 2.1660, 2.1485], [1.7808, 1.7808, 1.7808, ..., 2.1485, 2.1485, 2.1485], [1.7983, 1.7983, 1.7983, ..., 2.1310, 2.1310, 2.1310]], [[1.1934, 1.1934, 1.1934, ..., 1.0714, 1.0714, 1.0539], [1.1934, 1.1934, 1.1934, ..., 1.0365, 1.0365, 1.0365], [1.2108, 1.2108, 1.1759, ..., 1.0017, 1.0017, 0.9842], ..., [1.9254, 1.9254, 1.9080, ..., 2.3088, 2.3263, 2.3088], [1.9254, 1.9254, 1.9080, ..., 2.3088, 2.3088, 2.3088], [1.9428, 1.9428, 1.9254, ..., 2.2914, 2.2914, 2.2914]]]])torch.Size([1, 3, 224, 224]) 预测 使用torchvision库的DenseNet 121预训练模型来预测图像的类别 预测结果包含预测类id的索引，但最终要返回一个类别名称 下载包含了ImageNet的类别id到类别名称的映射的JSON文件：imagenet_class_index 12345678910111213141516171819202122# predict.pyimport jsonfrom torchvision import modelsfrom trans import transform_imageimagenet_class_index = json.load( open(&#x27;_static/imagenet_class_index.json&#x27;))model = models.densenet121(pretrained=True)model.eval()def get_prediction(image_bytes): tensor = transform_image(image_bytes=image_bytes) outputs = model.forward(tensor) _, y_hat = outputs.max(1) predicted_idx = str(y_hat.item()) return imagenet_class_index[predicted_idx]if __name__ == &#x27;__main__&#x27;: with open(&quot;_static/img/cindy.jpg&quot;, &#x27;rb&#x27;) as f: image_bytes = f.read() print(get_prediction(image_bytes=image_bytes)) 模型变量model是全局变量而不是get_prediction方法的一部分： 对于内存和计算而言，加载模型是一项昂贵的操作。 若在get_prediction方法中加载模型，那么每次调用该方法时都会不必要地加载它。 一个Web服务器每秒可能接收数千个请求，不应该浪费时间为每次推理冗余加载模型。因此，只将模型加载到内存中一次 在生产系统中必须高效使用算力才能大规模地服务请求，因此通常应该在服务请求之前加载模型 那我家的喵咪来测试一下： 12$ python predict.py[&#x27;n02123394&#x27;, &#x27;Persian_cat&#x27;] 整合在一起12345678910111213141516171819202122# app.pyfrom flask import Flask, request, jsonifyfrom predict import get_predictionapp = Flask(__name__)@app.route(&#x27;/predict&#x27;, methods=[&#x27;POST&#x27;])def predict(): if request.method == &#x27;POST&#x27;: file = request.files[&#x27;file&#x27;] image_bytes = file.read() class_id, class_name = get_prediction( image_bytes=image_bytes) return jsonify( &#123; &#x27;class_id&#x27;: class_id, &#x27;class_name&#x27;: class_name &#125; )if __name__==&#x27;__main__&#x27;: app.run() 写一个测试脚本，看看能不能辨别我家小狗： 1234567891011import requestsresp = requests.post( url=&quot;http://localhost:5000/predict&quot;, files=&#123; &quot;file&quot;: open(&quot;_static/img/almond.jpg&quot;, &#x27;rb&#x27;) &#125;)if __name__ == &#x27;__main__&#x27;: print(resp.json()) 1234# 运行Flask$ FLASK_ENV=development FLASK_APP=app.py flask run$ python test.py&#123;&#x27;class_id&#x27;: &#x27;n02086910&#x27;, &#x27;class_name&#x27;: &#x27;papillon&#x27;&#125; ┗|｀O′|┛咩啊！我家的杏仁是边牧啦！ TODO 换个模型？ 加点UI？ 生产部署？","categories":[{"name":"Tools","slug":"Tools","permalink":"https://huang-guoliang.github.io/categories/Tools/"},{"name":"PyTorch","slug":"Tools/PyTorch","permalink":"https://huang-guoliang.github.io/categories/Tools/PyTorch/"}],"tags":[{"name":"PyTorch","slug":"PyTorch","permalink":"https://huang-guoliang.github.io/tags/PyTorch/"},{"name":"Flask","slug":"Flask","permalink":"https://huang-guoliang.github.io/tags/Flask/"}]},{"title":"seaborn教程02-seaborn支持的数据格式","slug":"Tools/seaborn/seaborn-tutorial-02","date":"2022-01-20T09:01:36.000Z","updated":"2022-01-22T06:50:44.965Z","comments":true,"path":"posts/46da756c/","link":"","permalink":"https://huang-guoliang.github.io/posts/46da756c/","excerpt":"","text":"1234&gt;&gt;&gt; import matplotlib.pyplot as plt&gt;&gt;&gt; import seaborn as sns&gt;&gt;&gt; sns.__version__&#x27;0.11.2&#x27; 长格式数据(Long-form data)一个长格式数据的表格具有以下特征： 一列代表一个变量 一行代表一个观测结果(样本) 以航班(flights)数据集为例，它记录了从1949年到1960年每个月乘坐飞机的乘客数量。该数据集有三个变量(年、月和乘客数量): 12345678&gt;&gt;&gt; flights = sns.load_dataset(&quot;flights&quot;)&gt;&gt;&gt; flights.head() year month passengers0 1949 Jan 1121 1949 Feb 1182 1949 Mar 1323 1949 Apr 1294 1949 May 121 对于长格式数据，通过将表中的列显式分配给一个变量，就可以为它们在图中赋予角色。例如，制作每年乘客数量的月度图：12345678plot_long_form = sns.relplot( data=flights, x=&quot;year&quot;, y=&quot;passengers&quot;, hue=&quot;month&quot;, kind=&quot;line&quot;)plt.show() 宽格式数据(Wide-form data)一些简单的数据集采用宽格式，列和行包含不同变量的级别。通过“透视”的方式将航班数据集转换为宽格式： 12345678910111213&gt;&gt;&gt; flights_wide = flights.pivot(... index=&quot;year&quot;,... columns=&quot;month&quot;,... values=&quot;passengers&quot;... )&gt;&gt;&gt; flights_wide.head()month Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Decyear1949 112 118 132 129 121 135 148 148 136 119 104 1181950 115 126 141 135 125 149 170 170 158 133 114 1401951 145 150 178 163 172 178 199 199 184 162 146 1661952 171 180 193 181 183 218 230 242 209 191 172 1941953 196 196 236 235 229 243 264 272 237 211 180 201 12345&gt;&gt;&gt; plot_wide_form = sns.relplot(... data=flights_wide,... kind=&quot;line&quot;... )&gt;&gt;&gt; plt.show() 这个图与上一个图看似相似，但有明显的不同。Seaborn将DataFrame的索引year分配给x，将DataFrame的值分配给y，为每个月绘制了一条单独的线。当数据集通过pivot操作将其从长格式转换为宽格式时，乘客数量(passengers)的含义信息就丢失了。因此，图中没有y轴标签。(这些线在这里也有破折号，因为relplot()将列变量映射为颜色和样式语义，以便更容易访问plot。在长格式的情况下我们没有这样做，但是我们可以通过设置style=”month”来实现)。 宽格式数据可视化的选项","categories":[{"name":"Tools","slug":"Tools","permalink":"https://huang-guoliang.github.io/categories/Tools/"},{"name":"seaborn","slug":"Tools/seaborn","permalink":"https://huang-guoliang.github.io/categories/Tools/seaborn/"}],"tags":[{"name":"seaborn","slug":"seaborn","permalink":"https://huang-guoliang.github.io/tags/seaborn/"}]},{"title":"分子的机器学习描述符","slug":"Cheminformatics/mldscpts4m","date":"2022-01-19T00:49:44.000Z","updated":"2022-01-20T07:44:14.084Z","comments":true,"path":"posts/68090c70/","link":"","permalink":"https://huang-guoliang.github.io/posts/68090c70/","excerpt":"","text":"文章链接：Machine learning descriptors for molecules 适用于机器学习的描述符有哪些特点？ 描述符有哪些类型？ 如何选择描述符(组合)？ 总结 参考资料 在预测分子性质时，分子结构在被用来训练机器学习模型之前被转换成描述符(descriptors)。 本文的目的是概述分子描述符，并讨论三个主要问题: 适用于机器学习的描述符有哪些特点？选用一个满足以下三个标准的描述符来编码你的分子： 描述符与将要预测的分子性质有较高相关度； 不同的分子结构对应的描述符有不同的值(或表示)； 根据分子的大小来匹配合适的描述符(不是所有的描述符都适合所有大小的分子)。 针对具体的机器学习任务，描述符还需要遵循其他一些标准，例如： 能区分同分异构体； 可解码(从描述符返回到分子结构)； 数据量与描述符的维度(通常，数据集中的分子数量应远大于描述符的维数)。 描述符有哪些类型？分子描述符分为两类：实验性的描述符和理论性的描述符。 实验性的描述符(Experimental)实验测量或理论计算得到的物理化学性质。 理论性的描述符(Theoretical)来自于分子的符号表示。根据”维度“又可分为以下五类: 0维(0D)描述符 不提供任何有关分子结构或原子连通性信息的分子描述符。 例如，原子数、键数或分子量都是0D描述符。 它们的优点是很容易获得，但要与其他描述符组合使用； 1维(1D)描述符 由一组子结构(如官能团)计算得到的描述符。 其优点也是容易获得。 分子指纹就是一类最常见的1D描述符。 2维(2D)描述符 通过分子的图表示(graph representation)获得分子拓扑信息的描述符。 典型的2D描述符是邻接矩阵(Adjacency matrix)，库仑矩阵(Coulomb matrix)和距离矩阵(Distance matrix)。 由于2D描述符对分子的结构特征(大小、形状和对称性)很敏感，因此它们是常用的一类描述符。 3维(3D)描述符 提供有关分子原子空间坐标信息的几何描述符。 最著名的3D描述符是分子矩阵(Molecular matrix)和3D-MoRSE描述符。 由于几何描述符的复杂性，其计算十分耗时。 4维(4D)描述符： 也被称为“基于网格的描述符”。这类描述符除了分子几何外，还引入了第四维空间。 这个新维度通常表征分子与受体活性位点之间的相互作用或分子的多重构象状态。 常用的4D描述符有CoMFA和GRID。 一个优点是，它们提供了比其他描述符更多的信息，并且总是能够为结构不同的分子生成不同的值。 然而，如同3D描述符一样，4D描述符因其高复杂性而难以获得。 如何选择描述符(组合)？ 从海量描述符中选择合适的描述符(组合)是一项非常困难的任务。 主要有两种选择策略：穷举搜索和优化算法。 穷举搜索(Exhaustive search) 也就是全子集模型(All Subset Model, ASM)。 N个描述符就有2N-1种组合。 此策略理论上能找到最优的描述符组合，但描述符数量过大时极为消耗算力， 比较适合只考虑少量描述符的情况。 优化算法(Optimization algorithms) 是通过迭代方法找出能使预测模型结果最优的描述符组合。 比较常用的算法有进化规划(Evolutionary Programming，EP)，蚁群优化(Ant Colony Optimization，ACO)，顺序查找(Sequential Search，SS)和遗传算法(Genetic Algorithms，GAs)。 一般的优化流程如下图所示： 总结 分子用描述符表示后，可作为机器学习模型的特征输入。 描述符的选择很重要，因为它对模型的预测性能有很大的影响。 在选择描述符时，有四个关注点： 描述符与预测性质之间的相关性 描述符为结构不同的分子生成不同值的能力 描述符的维数 可用的数据量 描述符不能完全描述分子的结构复杂性，可通过使用高维描述符或多个描述符部分地解决。 使用高维描述符或描述符组合会增加模型的复杂度而降低算法的性能。 参考资料 st=>start: 开始优化 op1=>operation: 候选的描述符集合 op2=>operation: 描述符子集 cond=>condition: 预测模型评估 e=>end: 最优的描述符子集 st->op1->op2(right)->cond cond(no)->op1 cond(yes)->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);1.DScribe: Library of descriptors for machine learning in materials science ↩2.Molecular descriptors for structure–activity applications: a hands-on approach ↩","categories":[{"name":"Cheminformatics","slug":"Cheminformatics","permalink":"https://huang-guoliang.github.io/categories/Cheminformatics/"}],"tags":[{"name":"ML","slug":"ML","permalink":"https://huang-guoliang.github.io/tags/ML/"},{"name":"Descriptor","slug":"Descriptor","permalink":"https://huang-guoliang.github.io/tags/Descriptor/"}]},{"title":"seaborn教程01","slug":"Tools/seaborn/seaborn-tutorial-01","date":"2022-01-18T07:26:43.000Z","updated":"2022-01-20T08:31:48.208Z","comments":true,"path":"posts/bc466d5/","link":"","permalink":"https://huang-guoliang.github.io/posts/bc466d5/","excerpt":"","text":"","categories":[{"name":"Tools","slug":"Tools","permalink":"https://huang-guoliang.github.io/categories/Tools/"},{"name":"seaborn","slug":"Tools/seaborn","permalink":"https://huang-guoliang.github.io/categories/Tools/seaborn/"}],"tags":[]},{"title":"《深度学习在分子与材料中的应用》导览","slug":"Cheminformatics/dl4mm/dl4mm-00","date":"2022-01-18T06:19:04.000Z","updated":"2022-01-19T00:55:57.579Z","comments":true,"path":"posts/f25b25e8/","link":"","permalink":"https://huang-guoliang.github.io/posts/f25b25e8/","excerpt":"","text":"","categories":[{"name":"Cheminformatics","slug":"Cheminformatics","permalink":"https://huang-guoliang.github.io/categories/Cheminformatics/"},{"name":"dl4mm","slug":"Cheminformatics/dl4mm","permalink":"https://huang-guoliang.github.io/categories/Cheminformatics/dl4mm/"}],"tags":[]},{"title":"seaborn教程导览","slug":"Tools/seaborn/seaborn-tutorial-00","date":"2022-01-18T02:21:56.000Z","updated":"2022-01-19T09:48:06.015Z","comments":true,"path":"posts/a1871603/","link":"","permalink":"https://huang-guoliang.github.io/posts/a1871603/","excerpt":"","text":"教程目录 安装seaborn 小试牛刀 Seaborn是一个用Python制作统计图形的库。它构建在matplotlib之上，并与pandas数据结构紧密集成。它为绘制出吸引注意且信息丰富的统计图形提供了高级接口。 教程目录 API overview Overview of seaborn plotting functions Data structures accepted by seaborn Plotting functions Visualizing statistical relationships Visualizing distributions of data Plotting with categorical data Visualizing regression models Multi-plot grids Building structured multi-plot grids Plot aesthetics Controlling figure aesthetics Choosing color palettes 安装seaborn通过PyPI或Anaconda直接安装： 1234# pip安装pip install seaborn# 或conda安装conda install seaborn 小试牛刀1234567891011121314151617# 导入seaborn库import seaborn as sns# seaborn自带的示例数据集，# 是pandas的DataFrame格式的df = sns.load_dataset(&quot;penguins&quot;)# 如果在Jupyter Notebook上运行，# 可以直接显示出图片plot = sns.pairplot(data=df, hue=&quot;species&quot;)# 保存图片plot.figure.savefig(&quot;out.png&quot;)# 在非Jupyter Notebook环境中，# 在窗口中显示图片需要matplotlib的帮助import matplotlib.pyplot as pltplt.show() 轻松绘制出漂亮的图表：","categories":[{"name":"Tools","slug":"Tools","permalink":"https://huang-guoliang.github.io/categories/Tools/"},{"name":"seaborn","slug":"Tools/seaborn","permalink":"https://huang-guoliang.github.io/categories/Tools/seaborn/"}],"tags":[{"name":"seaborn","slug":"seaborn","permalink":"https://huang-guoliang.github.io/tags/seaborn/"}]},{"title":"《赤裸的统计学》第2章","slug":"Mathematics/Statistics/naked-stats/naked-stats-02","date":"2022-01-17T06:14:39.000Z","updated":"2022-01-19T00:55:26.152Z","comments":true,"path":"posts/dac470bb/","link":"","permalink":"https://huang-guoliang.github.io/posts/dac470bb/","excerpt":"","text":"CHAPTER 2. Descriptive Statistics: Who was the best baseball player of all time? 要点： 平均数容易受到远离[中心区域的“异常值”的干扰而出现失真。 标准差用于衡量数据相对于平均值的分散程度。 .article-entry table { width: 50%; } table th { width: 30px; } 0 1 2 3 4 5 6 7 8 9 &gt;10 competitor 12 14 36 13 8 6 5 3 0 2 1 your 25 31 9 4 3 0 0 1 1 0 26 123456import numpy as npcompet = [12, 14, 36, 13, 8, 6, 5, 3, 0, 2, 1]your = [25, 31, 9, 4, 3, 0, 0, 1, 1, 0, 26]","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/"},{"name":"Statistics","slug":"Mathematics/Statistics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/"},{"name":"naked-stats","slug":"Mathematics/Statistics/naked-stats","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/naked-stats/"}],"tags":[{"name":"Stats","slug":"Stats","permalink":"https://huang-guoliang.github.io/tags/Stats/"}]},{"title":"《赤裸的统计学》第1章","slug":"Mathematics/Statistics/naked-stats/naked-stats-01","date":"2022-01-17T02:52:26.000Z","updated":"2022-01-19T00:55:12.816Z","comments":true,"path":"posts/e1f2a54d/","link":"","permalink":"https://huang-guoliang.github.io/posts/e1f2a54d/","excerpt":"","text":"","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/"},{"name":"Statistics","slug":"Mathematics/Statistics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/"},{"name":"naked-stats","slug":"Mathematics/Statistics/naked-stats","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/naked-stats/"}],"tags":[{"name":"Stats","slug":"Stats","permalink":"https://huang-guoliang.github.io/tags/Stats/"}]},{"title":"《赤裸的统计学》目录","slug":"Mathematics/Statistics/naked-stats/naked-stats-00","date":"2022-01-17T02:42:23.000Z","updated":"2022-01-19T00:54:59.563Z","comments":true,"path":"posts/54daf226/","link":"","permalink":"https://huang-guoliang.github.io/posts/54daf226/","excerpt":"","text":"英文原版：Naked Statistics中文译版：赤裸的统计学 Introduction: Why I hated calculus but love statistics Chapter 01. What’s the Point? Chapter 02. Descriptive Statistics Chapter 03. Deceptive Description Chapter 04. Correlation Chapter 05. Basic Probability Chapter 05½. The Monty Hall Problem Chapter 06. Probems with Probaility Chapter 07. The Importance of Data Chapter 08. The Central Limit Theorm Chapter 09. Inference Chapter 10. Polling Chapter 11. Regression Analysis Chapter 12. Common Regression Mistakes Chapter 13. Program Evaluations","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/"},{"name":"Statistics","slug":"Mathematics/Statistics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/"},{"name":"naked-stats","slug":"Mathematics/Statistics/naked-stats","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/naked-stats/"}],"tags":[{"name":"Stats","slug":"Stats","permalink":"https://huang-guoliang.github.io/tags/Stats/"}]},{"title":"——欢迎光临我的博客——","slug":"index","date":"2022-01-15T08:18:40.000Z","updated":"2022-01-19T09:23:28.037Z","comments":true,"path":"posts/55bc8bfb/","link":"","permalink":"https://huang-guoliang.github.io/posts/55bc8bfb/","excerpt":"","text":"我是 老黄 小黄，一名本硕 光学专业 在 化工行业 打滚的 IT 工程师。现在主攻 机器学习 和 化学信息学。给我发信息：xh-notes@foxmail.com 课程： Dive into Deep Learning [课程地址] [视频地址] [我的笔记] 教程： Seaborn Tutorial [我的笔记] 书单： Deep Learning for Molecules and Materials; Andrew D. White; 2021. [在线阅读] [我的笔记] Deep Learning from Scratch; Seth Weidman; O’Reilly Media, Inc.; 2019. [我的笔记] Naked Statistics; Charles Wheelan; W. W. Norton &amp; Company, Inc.; 2013. [我的笔记] 文章： Machine learning descriptors for molecules; chemintelligence.com; 2021. [我的笔记]","categories":[],"tags":[]}],"categories":[{"name":"Tools","slug":"Tools","permalink":"https://huang-guoliang.github.io/categories/Tools/"},{"name":"PyTorch","slug":"Tools/PyTorch","permalink":"https://huang-guoliang.github.io/categories/Tools/PyTorch/"},{"name":"seaborn","slug":"Tools/seaborn","permalink":"https://huang-guoliang.github.io/categories/Tools/seaborn/"},{"name":"Cheminformatics","slug":"Cheminformatics","permalink":"https://huang-guoliang.github.io/categories/Cheminformatics/"},{"name":"dl4mm","slug":"Cheminformatics/dl4mm","permalink":"https://huang-guoliang.github.io/categories/Cheminformatics/dl4mm/"},{"name":"Mathematics","slug":"Mathematics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/"},{"name":"Statistics","slug":"Mathematics/Statistics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/"},{"name":"naked-stats","slug":"Mathematics/Statistics/naked-stats","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/naked-stats/"}],"tags":[{"name":"PyTorch","slug":"PyTorch","permalink":"https://huang-guoliang.github.io/tags/PyTorch/"},{"name":"Flask","slug":"Flask","permalink":"https://huang-guoliang.github.io/tags/Flask/"},{"name":"seaborn","slug":"seaborn","permalink":"https://huang-guoliang.github.io/tags/seaborn/"},{"name":"ML","slug":"ML","permalink":"https://huang-guoliang.github.io/tags/ML/"},{"name":"Descriptor","slug":"Descriptor","permalink":"https://huang-guoliang.github.io/tags/Descriptor/"},{"name":"Stats","slug":"Stats","permalink":"https://huang-guoliang.github.io/tags/Stats/"}]}