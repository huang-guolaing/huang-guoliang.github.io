{"meta":{"title":"小黄笔记本","subtitle":"xh-notes","description":"","author":"Huang Guoliang","url":"https://huang-guoliang.github.io","root":"/"},"pages":[{"title":"Categories","date":"2022-01-15T07:48:36.925Z","updated":"2022-01-15T07:48:36.925Z","comments":true,"path":"categories/index.html","permalink":"https://huang-guoliang.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2022-01-17T05:40:30.705Z","updated":"2022-01-17T05:40:30.705Z","comments":true,"path":"tags/index.html","permalink":"https://huang-guoliang.github.io/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2022-01-15T07:48:36.925Z","updated":"2022-01-15T07:48:36.925Z","comments":true,"path":"about/index.html","permalink":"https://huang-guoliang.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"2022年国际知识发现和数据挖掘竞赛","slug":"Machine Learning/Competition/kdd-cup-2022/kdd-cup-2022-00","date":"2022-04-03T04:37:37.000Z","updated":"2022-04-03T11:54:35.743Z","comments":true,"path":"posts/94b6e23/","link":"","permalink":"https://huang-guoliang.github.io/posts/94b6e23/","excerpt":"","text":"竞赛简介：空间动态风电功率的预测对风能的利用具有实际意义。参赛者须准确估计风力发电厂的风力供应。竞赛网址：Baidu KDD CUP 2022 引言空间动态风能预测挑战赛自1997年以来，与ACM SIGKDD知识发现和数据挖掘大会一起举办的KDD杯已成为一项重要的年度数据挖掘比赛。今年的KDD杯挑战任务既是有趣的技术挑战，且对风能的利用具有现实意义。在此，我们提出了一个空间动态的风电功率预测挑战，以促进数据驱动的机器学习方法对风电功率预测的进展。 动机风力预测(Wind Power Forecasting，WPF)旨在精确估计出风力发电厂在不同时间尺度下的电力供应。风电是一种清洁安全的可再生能源，但其产能的不持续性导致了供电高波动性。这种波动性给将风力发电纳入电网系统带来了巨大的挑战。为了保持供用电的平衡，风电的波动需要靠别的能源来弥补，但使用其他能源通常缓不济急(如燃煤电厂启动时间至少6小时)。因此，WPF被广泛认为是风电整合和运营中最关键的问题之一。在数据挖掘和机器学习领域，也涌现出大量关于风力发电预测问题的研究。然而，如何很好地处理WPF问题仍然是一项挑战，因为要保证电网的稳定和供应的安全，就必须要求较高的预测精度。 挑战赛概述此次竞赛提供了龙源电力集团特有的空间动态风电功率预测数据集SDWPF，该数据集包含了风电机组的空间分布，以及动态环境因素，如时间、天气和涡轮机内部状态。鉴于现有的大多数数据集和竞赛都把WPF视为一个时间序列预测问题，忽视了风力涡轮机的位置及环境信息。SDWPF数据集的示意图如下图所示。每台风力机可分别产生风电$T_i$，风电场的输出功率为所有风力机的功率之和。也就是说，在$t$时刻，风电场的输出功率$W=\\sum_iT_i$。 在此次竞赛任务中有两个不同于以往WPF比赛的特别设置: 空间分布：竞赛将提供风电厂所有风力涡轮机的相对位置，用于建模风力涡轮机之间的空间相关性。 动态上下文：提供重要天气情况和每个风力涡轮机监测的内部情况，以方便预测任务。 赛程每个截止时间都是AoE时间23:59 3月16日，开放报名网站。 3月20日，公布初始数据。参赛者将通过使用初始的WPF数据进行练习来熟悉赛题。 4月10日，公布全部数据。我们将发布所有的数据集和基线代码。 5月10日，开始提交。所有团队都可以尝试演示提交，以确保顺利提交最终测试。 6月20日，更新测试数据。将发布一个新的测试集用于测试预测。 7月15日，最后提交的截止日期。每个团队提交最终的预测模型。这些模型将在一个私有测试集上进行评估，以确定获奖候选人团队。 7月18日，通知获奖者。有关代码和技术论文的通知和说明将会以私人方式发送给获奖者。 7月21日，获奖者的代码和技术论文提交截止日期。 7月22日，公布获奖者。 8月01日，修订技术论文的截止日期。 8月15日，KDD杯研讨会。 奖励常规奖第1名：\\$10,000第2名：\\$5,000第3名：\\$3,000第4-10名：各\\$1000对于前15名的选手，我们将各颁发一份等级证书。 飞桨特别奖：对于使用PaddlePaddle作为深度学习平台实现挑战解决方案的团队，我们提供了一个特别的PaddlePaddle赛道，并颁发奖品:第1名：\\$3,000第2名：\\$2,000第3名：\\$1,500第4-10名：各\\$500对于前15名的选手，我们将各颁发一份飞桨专用赛道的等级证书。所有使用飞桨的队伍都有资格获得常规奖和飞桨特别奖。 所有获奖的团队成员都将获得百度公司的直接面试推荐，无需进行笔试。 规则 每个提交的文件不能超过200MB。 每个团队每天最多可以提交3次(在AOE时间23:59刷新)。 获奖者必须提交完整的代码和一份完整的可复现结果的技术细节报告。获奖团队的代码和报告提交说明将会发布。 没有竞赛组织方的批准，竞赛中不能使用任何外部数据。 每位参赛者只可参加一组比赛。如果挑战组织者发现和/或提供证据，任何参加超过一个队的参赛者可能被取消资格，她/他对应的队可能被取消资格。 任何与百度公司、龙源动力集团(员工、合作伙伴等)有利益冲突的参赛者，不得参加比赛，也无资格获奖。挑战组织者保留核实此类利益冲突的权利。 每个参赛者参加挑战的资格应符合您的雇主/组织的规则/政策，KDD Cup 2022的规则/政策，以及SIGKDD (ACM知识发现和数据挖掘特别兴趣小组)的规则/政策。挑战组织者撤销核实这种资格的权利。 挑战赛主办单位保留在任何时间以任何理由限制或限制任何人参加挑战赛的权利。 1)未在规定时间内提交代码和报告，2)提交的代码不能复制获奖结果，3)提交的技术报告与代码不一致，4)违反其他规则的，将取消获奖资格。 挑战赛主办单位保留更新奖项设置、比赛时间及规则的权利。 研讨会时程前三名的团队和一些被选中的其他团队将被邀请在KDD杯研讨会上展示他们的解决方案，与KDD会议一起。 咨询方式任何关于挑战的查询和问题都可以发送到kddcup2022@baidu.com。关于挑战的讨论或一般性问题，请使用Github discussion。 任务内容数据描述来自风电场的风力涡轮机监控与数据采集系统（Supervisory Control and Data Acquisition, SCADA）的情景监测数据将会公布。这些SCADA数据是从龙源电力集团所拥有的风电场（通常由50-200台风力涡轮机组成）的每个风力涡轮机中每15分钟采样一次得到的。该数据集包括影响风力发电的关键外部特征，如风速、风向、外部温度，以及重要的内部特征，如涡轮机转子转速、发电机温度、轮毂温度，可指示每台风力机的运行状态。此外，还将发布风电场中所有风力机的相对距离矩阵，以表征风力机之间的空间相关性。 完整的数据集将于4月10日发布。 关于风力发电机的图示如下: 下面详细介绍了数据的每个列的语义含义： # 列名 描述 1 TurbID 风力涡轮机ID 2 Day 记录的日期 3 Tmstamp 新增数据的时间戳 4 Wspd (m/s) 风速表所记录的风速 5 Wdir(°) 风向与涡轮发动机舱位置之间的夹角 2 3 6 Etmp (℃) 周围环境的温度 7 Itmp (℃) 涡轮发动机舱内的温度 8 Ndir (°) 发动机舱方向，即发动机舱的偏航角 9 Pab1 (°) 叶片1俯仰角 10 Pab2 (°) 叶片2俯仰角 11 Pab3 (°) 叶片3俯仰角 12 Prtv (kW) 无功功率 13 Patv (kW) 有功功率（目标变量） 评估这是一个提前42小时预测空间动态风力发电的挑战。例如，某天早上6点，根据风电场和风力发电机的一系列历史数据，从第二天凌晨0点开始有效预测风力发电。具体来说，在某一时刻，需要预测一个未来长度为168的风力供电时间序列，评估最后96个点的供电值。以均方根误差（Root Mean Square Error, RMSE）和平均绝对误差（Mean Absolute Error, MAE）的平均值作为主要评价分数。理论上，在一个时间点$t_0$，需要预测风电场输出风电功率的时间序列： P = \\{ P_{t_0+1}, P_{t_0+2}, P_{t_0+3}, \\cdots , P_{t_0+168} \\}。评价分数定义为： score = \\sqrt{\\frac{\\sum\\limits_{i=73}^{168}(P_{t_0+i} - \\widehat{P}_{t_0+i})^2}{96}} + \\frac{\\sum\\limits_{i=73}^{168}|P_{t_0+i} - \\widehat{P}_{t_0+i}|}{96}其中\\widehat{P}_{t_0+i}为实际功率，P_{t_0+i}为风电场在t_0+i时的预测功率。我们通过增加$t_0$来使用滑动窗口。平均每15分钟计算一次评分。计算分数的示例代码将会提供。此外，获胜的团队需要提交源代码和技术报告，以保证模型的重现性。获奖团队的代码和报告提交说明将于稍后公布。 数据集初始数据集：[initial_kddcup.csv]{https://bj.bcebos.com/v1/ai-studio-online/3008e18f8bb94d3fbc7b62ccd45eacb27abec26342d649f18f244a60cc3578a0?responseContentDisposition=attachment%3B%20filename%3Dsdwpf134_initial_kddcup.csv&amp;authorization=bce-auth-v1%2F0ef6765c1e494918bc0d4c3ca3e5c6d1%2F2022-03-22T00%3A56%3A15Z%2F-1%2F%2Fa4c9943681828da485d209acd2eda686003aa8355f6aaeccdf652d8d7bd63027} 此文件为空间动态风力发电预测的初始数据集。该数据集覆盖7天，包括13个列。完整的数据集将覆盖更长的时间范围，并包括更多的列。预测目标值为全部134台风力机的Patv之和(参见任务内容)。 参考资料1 https://en.wikipedia.org/wiki/File:EERE_illust_large_turbine.gif2 https://en.wikipedia.org/wiki/Wind_turbine#Horizontal_axis3 https://en.wikipedia.org/wiki/Wind_turbine#Components","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://huang-guoliang.github.io/categories/Machine-Learning/"},{"name":"Competition","slug":"Machine-Learning/Competition","permalink":"https://huang-guoliang.github.io/categories/Machine-Learning/Competition/"},{"name":"kdd-cup-2022","slug":"Machine-Learning/Competition/kdd-cup-2022","permalink":"https://huang-guoliang.github.io/categories/Machine-Learning/Competition/kdd-cup-2022/"}],"tags":[{"name":"Competition","slug":"Competition","permalink":"https://huang-guoliang.github.io/tags/Competition/"}]},{"title":"《贝叶斯思维(第二版)》辅助代码(1)","slug":"Mathematics/Statistics/think-bayes/think-bayes-00a","date":"2022-04-02T11:44:24.000Z","updated":"2022-04-02T14:40:52.799Z","comments":true,"path":"posts/78bb6cc/","link":"","permalink":"https://huang-guoliang.github.io/posts/78bb6cc/","excerpt":"","text":"本篇记录一些在《贝叶斯思维(第二版)》书中使用到的Python代码。 作者为配合书中讲解专门写了一个名为“empiricaldist”的Python library。该库包含了一些经验分布(empirical distribution)的类及相关函数。 可以用pip直接安装1python -m pip install empiricaldist Github地址：empiricaldist 1234567import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom scipy.interpolate import interp1d","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/"},{"name":"Statistics","slug":"Mathematics/Statistics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/"},{"name":"think-bayes","slug":"Mathematics/Statistics/think-bayes","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/think-bayes/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://huang-guoliang.github.io/tags/Python/"}]},{"title":"《贝叶斯思维(第二版)》目录","slug":"Mathematics/Statistics/think-bayes/think-bayes-00","date":"2022-04-02T11:20:48.000Z","updated":"2022-04-02T11:45:49.016Z","comments":true,"path":"posts/e918a543/","link":"","permalink":"https://huang-guoliang.github.io/posts/e918a543/","excerpt":"","text":"在线版本：Think Bayes 2 Chapter 00. Some Python ScriptsChapter 01. ProbabilityChapter 02. Bayes’s TheoremChapter 03. DistributionsChapter 04. Estimating ProportionsChapter 05. Estimating CountsChapter 06. Odds and AddendsChapter 07. Minimum, Maximum, and MixtureChapter 08. Poisson ProcessesChapter 09. Decision AnalysisChapter 10. TestingChapter 11. ComparisonChapter 12. ClassificationChapter 13. InferenceChapter 14. Survival AnalysisChapter 15. Mark and RecaptureChapter 16. Logistic RegressionChapter 17. RegressionChapter 18. Conjugate PriorsChapter 19. MCMCChapter 20. Approximate Bayesian Computation","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/"},{"name":"Statistics","slug":"Mathematics/Statistics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/"},{"name":"think-bayes","slug":"Mathematics/Statistics/think-bayes","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/think-bayes/"}],"tags":[{"name":"Stats","slug":"Stats","permalink":"https://huang-guoliang.github.io/tags/Stats/"},{"name":"Bayes","slug":"Bayes","permalink":"https://huang-guoliang.github.io/tags/Bayes/"}]},{"title":"通过Flask REST API部署PyTorch","slug":"Tools/PyTorch/deploy-pytorch-with-flask","date":"2022-01-22T06:52:41.000Z","updated":"2022-01-22T09:08:27.721Z","comments":true,"path":"posts/42477f40/","link":"","permalink":"https://huang-guoliang.github.io/posts/42477f40/","excerpt":"","text":"原文链接：Deploying PyTorch in Python via a REST API with Flask 任务：部署一个预训练的DenseNet 121模型来检测图像。 定义API接口 安装依赖 用Flask写一个极简的Web服务 写一个推断模型 处理图像 预测 整合在一起 TODO 定义API接口 API端点/predict接收POST请求 该请求file参数指定一个图像文件 返回的将是包含预测值的JSON响应：1234&#123; &quot;class_id&quot;: &quot;n02124075&quot;, &quot;class_name&quot;: &quot;Egyptian_cat&quot;&#125; 安装依赖可以先新建一个环境(省略)1$ pip install Flask==2.0.1 torchvision==0.10.0 用Flask写一个极简的Web服务参考Flask文档A Minimal Application 12345678# app.pyfrom flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def hello(): return &quot;Hello!&quot; 用开发模型来运行这个服务:1$ FLASK_ENV=development FLASK_APP=app.py flask run在浏览器访问http://localhost:5000/: 1234567891011121314# app.pyfrom flask import Flask, jsonifyapp = Flask(__name__)@app.route(&quot;/predict&quot;, methods=[&quot;POST&quot;])def predict(): # jsonify将数据序列化为JSON，并在响应中 # 指定了application/json内容类型 return jsonify( &#123; &quot;class_id&quot;: &quot;n02124075&quot;, &quot;class_name&quot;: &quot;Egyptian_cat&quot; ) 写一个推断模型处理图像 DenseNet模型要求图像为3通道RGB图像，大小为224x224 使用ImageNet设计的均值和标准差值对图像张量进行归一化 使用torchvision库中转换器transforms构建一个转换管道来处理图像 123456789101112131415161718192021222324# trans.pyimport ioimport torchvision.transforms as transformsfrom PIL import Imagedef transform_image(image_bytes): my_transforms = transforms.Compose( [ transforms.Resize(size=255), transforms.CenterCrop(size=224), transforms.ToTensor(), transforms.Normalize( mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]) ] ) image = Image.open(io.BytesIO(image_bytes)) return my_transforms(image).unsqueeze(0)if __name__ == &#x27;__main__&#x27;: with open(&quot;_static/img/cindy.jpg&quot;, &#x27;rb&#x27;) as f: image_bytes = f.read() tensor = transform_image(image_bytes=image_bytes) print(tensor) 用一张图片测试一下：12345678910111213141516171819202122232425$ python trans.py tensor([[[[0.9474, 0.9474, 0.9646, ..., 0.5878, 0.5878, 0.5707], [0.9474, 0.9646, 0.9817, ..., 0.5536, 0.5536, 0.5536], [0.9474, 0.9817, 0.9817, ..., 0.5193, 0.5193, 0.5022], ..., [1.6324, 1.6153, 1.5982, ..., 2.0434, 2.0605, 2.0434], [1.6324, 1.6153, 1.5982, ..., 2.0434, 2.0434, 2.0434], [1.6495, 1.6324, 1.6153, ..., 2.0263, 2.0263, 2.0263]], [[1.0280, 1.0455, 1.0630, ..., 1.0280, 1.0280, 1.0105], [1.0280, 1.0455, 1.0805, ..., 0.9930, 0.9930, 0.9930], [1.0280, 1.0630, 1.0805, ..., 0.9580, 0.9580, 0.9405], ..., [1.7808, 1.7808, 1.7808, ..., 2.1485, 2.1660, 2.1485], [1.7808, 1.7808, 1.7808, ..., 2.1485, 2.1485, 2.1485], [1.7983, 1.7983, 1.7983, ..., 2.1310, 2.1310, 2.1310]], [[1.1934, 1.1934, 1.1934, ..., 1.0714, 1.0714, 1.0539], [1.1934, 1.1934, 1.1934, ..., 1.0365, 1.0365, 1.0365], [1.2108, 1.2108, 1.1759, ..., 1.0017, 1.0017, 0.9842], ..., [1.9254, 1.9254, 1.9080, ..., 2.3088, 2.3263, 2.3088], [1.9254, 1.9254, 1.9080, ..., 2.3088, 2.3088, 2.3088], [1.9428, 1.9428, 1.9254, ..., 2.2914, 2.2914, 2.2914]]]])torch.Size([1, 3, 224, 224]) 预测 使用torchvision库的DenseNet 121预训练模型来预测图像的类别 预测结果包含预测类id的索引，但最终要返回一个类别名称 下载包含了ImageNet的类别id到类别名称的映射的JSON文件：imagenet_class_index 12345678910111213141516171819202122# predict.pyimport jsonfrom torchvision import modelsfrom trans import transform_imageimagenet_class_index = json.load( open(&#x27;_static/imagenet_class_index.json&#x27;))model = models.densenet121(pretrained=True)model.eval()def get_prediction(image_bytes): tensor = transform_image(image_bytes=image_bytes) outputs = model.forward(tensor) _, y_hat = outputs.max(1) predicted_idx = str(y_hat.item()) return imagenet_class_index[predicted_idx]if __name__ == &#x27;__main__&#x27;: with open(&quot;_static/img/cindy.jpg&quot;, &#x27;rb&#x27;) as f: image_bytes = f.read() print(get_prediction(image_bytes=image_bytes)) 模型变量model是全局变量而不是get_prediction方法的一部分： 对于内存和计算而言，加载模型是一项昂贵的操作。 若在get_prediction方法中加载模型，那么每次调用该方法时都会不必要地加载它。 一个Web服务器每秒可能接收数千个请求，不应该浪费时间为每次推理冗余加载模型。因此，只将模型加载到内存中一次 在生产系统中必须高效使用算力才能大规模地服务请求，因此通常应该在服务请求之前加载模型 那我家的喵咪来测试一下： 12$ python predict.py[&#x27;n02123394&#x27;, &#x27;Persian_cat&#x27;] 整合在一起12345678910111213141516171819202122# app.pyfrom flask import Flask, request, jsonifyfrom predict import get_predictionapp = Flask(__name__)@app.route(&#x27;/predict&#x27;, methods=[&#x27;POST&#x27;])def predict(): if request.method == &#x27;POST&#x27;: file = request.files[&#x27;file&#x27;] image_bytes = file.read() class_id, class_name = get_prediction( image_bytes=image_bytes) return jsonify( &#123; &#x27;class_id&#x27;: class_id, &#x27;class_name&#x27;: class_name &#125; )if __name__==&#x27;__main__&#x27;: app.run() 写一个测试脚本，看看能不能辨别我家小狗： 1234567891011import requestsresp = requests.post( url=&quot;http://localhost:5000/predict&quot;, files=&#123; &quot;file&quot;: open(&quot;_static/img/almond.jpg&quot;, &#x27;rb&#x27;) &#125;)if __name__ == &#x27;__main__&#x27;: print(resp.json()) 1234# 运行Flask$ FLASK_ENV=development FLASK_APP=app.py flask run$ python test.py&#123;&#x27;class_id&#x27;: &#x27;n02086910&#x27;, &#x27;class_name&#x27;: &#x27;papillon&#x27;&#125; ┗|｀O′|┛咩啊！我家的杏仁是边牧啦！ TODO 换个模型？ 加点UI？ 生产部署？","categories":[{"name":"Tools","slug":"Tools","permalink":"https://huang-guoliang.github.io/categories/Tools/"},{"name":"PyTorch","slug":"Tools/PyTorch","permalink":"https://huang-guoliang.github.io/categories/Tools/PyTorch/"}],"tags":[{"name":"PyTorch","slug":"PyTorch","permalink":"https://huang-guoliang.github.io/tags/PyTorch/"},{"name":"Flask","slug":"Flask","permalink":"https://huang-guoliang.github.io/tags/Flask/"}]},{"title":"seaborn教程02-seaborn支持的数据格式","slug":"Tools/seaborn/seaborn-tutorial-02","date":"2022-01-20T09:01:36.000Z","updated":"2022-01-22T06:50:44.965Z","comments":true,"path":"posts/46da756c/","link":"","permalink":"https://huang-guoliang.github.io/posts/46da756c/","excerpt":"","text":"1234&gt;&gt;&gt; import matplotlib.pyplot as plt&gt;&gt;&gt; import seaborn as sns&gt;&gt;&gt; sns.__version__&#x27;0.11.2&#x27; 长格式数据(Long-form data)一个长格式数据的表格具有以下特征： 一列代表一个变量 一行代表一个观测结果(样本) 以航班(flights)数据集为例，它记录了从1949年到1960年每个月乘坐飞机的乘客数量。该数据集有三个变量(年、月和乘客数量): 12345678&gt;&gt;&gt; flights = sns.load_dataset(&quot;flights&quot;)&gt;&gt;&gt; flights.head() year month passengers0 1949 Jan 1121 1949 Feb 1182 1949 Mar 1323 1949 Apr 1294 1949 May 121 对于长格式数据，通过将表中的列显式分配给一个变量，就可以为它们在图中赋予角色。例如，制作每年乘客数量的月度图：12345678plot_long_form = sns.relplot( data=flights, x=&quot;year&quot;, y=&quot;passengers&quot;, hue=&quot;month&quot;, kind=&quot;line&quot;)plt.show() 宽格式数据(Wide-form data)一些简单的数据集采用宽格式，列和行包含不同变量的级别。通过“透视”的方式将航班数据集转换为宽格式： 12345678910111213&gt;&gt;&gt; flights_wide = flights.pivot(... index=&quot;year&quot;,... columns=&quot;month&quot;,... values=&quot;passengers&quot;... )&gt;&gt;&gt; flights_wide.head()month Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Decyear1949 112 118 132 129 121 135 148 148 136 119 104 1181950 115 126 141 135 125 149 170 170 158 133 114 1401951 145 150 178 163 172 178 199 199 184 162 146 1661952 171 180 193 181 183 218 230 242 209 191 172 1941953 196 196 236 235 229 243 264 272 237 211 180 201 12345&gt;&gt;&gt; plot_wide_form = sns.relplot(... data=flights_wide,... kind=&quot;line&quot;... )&gt;&gt;&gt; plt.show() 这个图与上一个图看似相似，但有明显的不同。Seaborn将DataFrame的索引year分配给x，将DataFrame的值分配给y，为每个月绘制了一条单独的线。当数据集通过pivot操作将其从长格式转换为宽格式时，乘客数量(passengers)的含义信息就丢失了。因此，图中没有y轴标签。(这些线在这里也有破折号，因为relplot()将列变量映射为颜色和样式语义，以便更容易访问plot。在长格式的情况下我们没有这样做，但是我们可以通过设置style=”month”来实现)。 宽格式数据可视化的选项","categories":[{"name":"Tools","slug":"Tools","permalink":"https://huang-guoliang.github.io/categories/Tools/"},{"name":"seaborn","slug":"Tools/seaborn","permalink":"https://huang-guoliang.github.io/categories/Tools/seaborn/"}],"tags":[{"name":"seaborn","slug":"seaborn","permalink":"https://huang-guoliang.github.io/tags/seaborn/"}]},{"title":"分子的机器学习描述符","slug":"Cheminformatics/mldscpts4m","date":"2022-01-19T00:49:44.000Z","updated":"2022-01-20T07:44:14.084Z","comments":true,"path":"posts/68090c70/","link":"","permalink":"https://huang-guoliang.github.io/posts/68090c70/","excerpt":"","text":"文章链接：Machine learning descriptors for molecules 适用于机器学习的描述符有哪些特点？ 描述符有哪些类型？ 如何选择描述符(组合)？ 总结 参考资料 在预测分子性质时，分子结构在被用来训练机器学习模型之前被转换成描述符(descriptors)。 本文的目的是概述分子描述符，并讨论三个主要问题: 适用于机器学习的描述符有哪些特点？选用一个满足以下三个标准的描述符来编码你的分子： 描述符与将要预测的分子性质有较高相关度； 不同的分子结构对应的描述符有不同的值(或表示)； 根据分子的大小来匹配合适的描述符(不是所有的描述符都适合所有大小的分子)。 针对具体的机器学习任务，描述符还需要遵循其他一些标准，例如： 能区分同分异构体； 可解码(从描述符返回到分子结构)； 数据量与描述符的维度(通常，数据集中的分子数量应远大于描述符的维数)。 描述符有哪些类型？分子描述符分为两类：实验性的描述符和理论性的描述符。 实验性的描述符(Experimental)实验测量或理论计算得到的物理化学性质。 理论性的描述符(Theoretical)来自于分子的符号表示。根据”维度“又可分为以下五类: 0维(0D)描述符 不提供任何有关分子结构或原子连通性信息的分子描述符。 例如，原子数、键数或分子量都是0D描述符。 它们的优点是很容易获得，但要与其他描述符组合使用； 1维(1D)描述符 由一组子结构(如官能团)计算得到的描述符。 其优点也是容易获得。 分子指纹就是一类最常见的1D描述符。 2维(2D)描述符 通过分子的图表示(graph representation)获得分子拓扑信息的描述符。 典型的2D描述符是邻接矩阵(Adjacency matrix)，库仑矩阵(Coulomb matrix)和距离矩阵(Distance matrix)。 由于2D描述符对分子的结构特征(大小、形状和对称性)很敏感，因此它们是常用的一类描述符。 3维(3D)描述符 提供有关分子原子空间坐标信息的几何描述符。 最著名的3D描述符是分子矩阵(Molecular matrix)和3D-MoRSE描述符。 由于几何描述符的复杂性，其计算十分耗时。 4维(4D)描述符： 也被称为“基于网格的描述符”。这类描述符除了分子几何外，还引入了第四维空间。 这个新维度通常表征分子与受体活性位点之间的相互作用或分子的多重构象状态。 常用的4D描述符有CoMFA和GRID。 一个优点是，它们提供了比其他描述符更多的信息，并且总是能够为结构不同的分子生成不同的值。 然而，如同3D描述符一样，4D描述符因其高复杂性而难以获得。 如何选择描述符(组合)？ 从海量描述符中选择合适的描述符(组合)是一项非常困难的任务。 主要有两种选择策略：穷举搜索和优化算法。 穷举搜索(Exhaustive search) 也就是全子集模型(All Subset Model, ASM)。 N个描述符就有2N-1种组合。 此策略理论上能找到最优的描述符组合，但描述符数量过大时极为消耗算力， 比较适合只考虑少量描述符的情况。 优化算法(Optimization algorithms) 是通过迭代方法找出能使预测模型结果最优的描述符组合。 比较常用的算法有进化规划(Evolutionary Programming，EP)，蚁群优化(Ant Colony Optimization，ACO)，顺序查找(Sequential Search，SS)和遗传算法(Genetic Algorithms，GAs)。 一般的优化流程如下图所示： 总结 分子用描述符表示后，可作为机器学习模型的特征输入。 描述符的选择很重要，因为它对模型的预测性能有很大的影响。 在选择描述符时，有四个关注点： 描述符与预测性质之间的相关性 描述符为结构不同的分子生成不同值的能力 描述符的维数 可用的数据量 描述符不能完全描述分子的结构复杂性，可通过使用高维描述符或多个描述符部分地解决。 使用高维描述符或描述符组合会增加模型的复杂度而降低算法的性能。 参考资料 st=>start: 开始优化 op1=>operation: 候选的描述符集合 op2=>operation: 描述符子集 cond=>condition: 预测模型评估 e=>end: 最优的描述符子集 st->op1->op2(right)->cond cond(no)->op1 cond(yes)->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);1.DScribe: Library of descriptors for machine learning in materials science ↩2.Molecular descriptors for structure–activity applications: a hands-on approach ↩","categories":[{"name":"Cheminformatics","slug":"Cheminformatics","permalink":"https://huang-guoliang.github.io/categories/Cheminformatics/"}],"tags":[{"name":"ML","slug":"ML","permalink":"https://huang-guoliang.github.io/tags/ML/"},{"name":"Descriptor","slug":"Descriptor","permalink":"https://huang-guoliang.github.io/tags/Descriptor/"}]},{"title":"seaborn教程01","slug":"Tools/seaborn/seaborn-tutorial-01","date":"2022-01-18T07:26:43.000Z","updated":"2022-01-20T08:31:48.208Z","comments":true,"path":"posts/bc466d5/","link":"","permalink":"https://huang-guoliang.github.io/posts/bc466d5/","excerpt":"","text":"","categories":[{"name":"Tools","slug":"Tools","permalink":"https://huang-guoliang.github.io/categories/Tools/"},{"name":"seaborn","slug":"Tools/seaborn","permalink":"https://huang-guoliang.github.io/categories/Tools/seaborn/"}],"tags":[]},{"title":"《深度学习在分子与材料中的应用》导览","slug":"Cheminformatics/dl4mm/dl4mm-00","date":"2022-01-18T06:19:04.000Z","updated":"2022-01-19T00:55:57.579Z","comments":true,"path":"posts/f25b25e8/","link":"","permalink":"https://huang-guoliang.github.io/posts/f25b25e8/","excerpt":"","text":"","categories":[{"name":"Cheminformatics","slug":"Cheminformatics","permalink":"https://huang-guoliang.github.io/categories/Cheminformatics/"},{"name":"dl4mm","slug":"Cheminformatics/dl4mm","permalink":"https://huang-guoliang.github.io/categories/Cheminformatics/dl4mm/"}],"tags":[]},{"title":"seaborn教程导览","slug":"Tools/seaborn/seaborn-tutorial-00","date":"2022-01-18T02:21:56.000Z","updated":"2022-01-19T09:48:06.015Z","comments":true,"path":"posts/a1871603/","link":"","permalink":"https://huang-guoliang.github.io/posts/a1871603/","excerpt":"","text":"教程目录 安装seaborn 小试牛刀 Seaborn是一个用Python制作统计图形的库。它构建在matplotlib之上，并与pandas数据结构紧密集成。它为绘制出吸引注意且信息丰富的统计图形提供了高级接口。 教程目录 API overview Overview of seaborn plotting functions Data structures accepted by seaborn Plotting functions Visualizing statistical relationships Visualizing distributions of data Plotting with categorical data Visualizing regression models Multi-plot grids Building structured multi-plot grids Plot aesthetics Controlling figure aesthetics Choosing color palettes 安装seaborn通过PyPI或Anaconda直接安装： 1234# pip安装pip install seaborn# 或conda安装conda install seaborn 小试牛刀1234567891011121314151617# 导入seaborn库import seaborn as sns# seaborn自带的示例数据集，# 是pandas的DataFrame格式的df = sns.load_dataset(&quot;penguins&quot;)# 如果在Jupyter Notebook上运行，# 可以直接显示出图片plot = sns.pairplot(data=df, hue=&quot;species&quot;)# 保存图片plot.figure.savefig(&quot;out.png&quot;)# 在非Jupyter Notebook环境中，# 在窗口中显示图片需要matplotlib的帮助import matplotlib.pyplot as pltplt.show() 轻松绘制出漂亮的图表：","categories":[{"name":"Tools","slug":"Tools","permalink":"https://huang-guoliang.github.io/categories/Tools/"},{"name":"seaborn","slug":"Tools/seaborn","permalink":"https://huang-guoliang.github.io/categories/Tools/seaborn/"}],"tags":[{"name":"seaborn","slug":"seaborn","permalink":"https://huang-guoliang.github.io/tags/seaborn/"}]},{"title":"《赤裸的统计学》第2章","slug":"Mathematics/Statistics/naked-stats/naked-stats-02","date":"2022-01-17T06:14:39.000Z","updated":"2022-04-03T10:49:17.097Z","comments":true,"path":"posts/dac470bb/","link":"","permalink":"https://huang-guoliang.github.io/posts/dac470bb/","excerpt":"","text":"CHAPTER 2. Descriptive Statistics: Who was the best baseball player of all time? 要点： 平均数容易受到远离[中心区域的“异常值”的干扰而出现失真。 标准差用于衡量数据相对于平均值的分散程度。 .article-entry table { width: 50%; } table th { width: 30px; } 0 1 2 3 4 5 6 7 8 9 &gt;10 competitor 12 14 36 13 8 6 5 3 0 2 1 your 25 31 9 4 3 0 0 1 1 0 26 123456import numpy as npcompet = [12, 14, 36, 13, 8, 6, 5, 3, 0, 2, 1]your = [25, 31, 9, 4, 3, 0, 0, 1, 1, 0, 26]","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/"},{"name":"Statistics","slug":"Mathematics/Statistics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/"},{"name":"naked-stats","slug":"Mathematics/Statistics/naked-stats","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/naked-stats/"}],"tags":[{"name":"Stats","slug":"Stats","permalink":"https://huang-guoliang.github.io/tags/Stats/"}]},{"title":"《赤裸的统计学》第1章","slug":"Mathematics/Statistics/naked-stats/naked-stats-01","date":"2022-01-17T02:52:26.000Z","updated":"2022-01-19T00:55:12.816Z","comments":true,"path":"posts/e1f2a54d/","link":"","permalink":"https://huang-guoliang.github.io/posts/e1f2a54d/","excerpt":"","text":"","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/"},{"name":"Statistics","slug":"Mathematics/Statistics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/"},{"name":"naked-stats","slug":"Mathematics/Statistics/naked-stats","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/naked-stats/"}],"tags":[{"name":"Stats","slug":"Stats","permalink":"https://huang-guoliang.github.io/tags/Stats/"}]},{"title":"《赤裸的统计学》目录","slug":"Mathematics/Statistics/naked-stats/naked-stats-00","date":"2022-01-17T02:42:23.000Z","updated":"2022-01-19T00:54:59.563Z","comments":true,"path":"posts/54daf226/","link":"","permalink":"https://huang-guoliang.github.io/posts/54daf226/","excerpt":"","text":"英文原版：Naked Statistics中文译版：赤裸的统计学 Introduction: Why I hated calculus but love statistics Chapter 01. What’s the Point? Chapter 02. Descriptive Statistics Chapter 03. Deceptive Description Chapter 04. Correlation Chapter 05. Basic Probability Chapter 05½. The Monty Hall Problem Chapter 06. Probems with Probaility Chapter 07. The Importance of Data Chapter 08. The Central Limit Theorm Chapter 09. Inference Chapter 10. Polling Chapter 11. Regression Analysis Chapter 12. Common Regression Mistakes Chapter 13. Program Evaluations","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/"},{"name":"Statistics","slug":"Mathematics/Statistics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/"},{"name":"naked-stats","slug":"Mathematics/Statistics/naked-stats","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/naked-stats/"}],"tags":[{"name":"Stats","slug":"Stats","permalink":"https://huang-guoliang.github.io/tags/Stats/"}]},{"title":"——欢迎光临我的博客——","slug":"index","date":"2022-01-15T08:18:40.000Z","updated":"2022-04-02T11:36:30.564Z","comments":true,"path":"posts/55bc8bfb/","link":"","permalink":"https://huang-guoliang.github.io/posts/55bc8bfb/","excerpt":"","text":"我是 老黄 小黄，一名本硕 光学专业 在 化工行业 打滚的 IT 工程师。现在主攻 机器学习 和 化学信息学。给我发信息：xh-notes@foxmail.com 课程： Dive into Deep Learning [课程地址] [视频地址] [我的笔记] 教程： Seaborn Tutorial [我的笔记] 书单： Think Bayes (2nd); Allen B. Downey; 2021. [在线阅读] [我的笔记] Deep Learning for Molecules and Materials; Andrew D. White; 2021. [在线阅读] [我的笔记] Deep Learning from Scratch; Seth Weidman; O’Reilly Media, Inc.; 2019. [我的笔记] Naked Statistics; Charles Wheelan; W. W. Norton &amp; Company, Inc.; 2013. [我的笔记] 文章： Machine learning descriptors for molecules; chemintelligence.com; 2021. [我的笔记]","categories":[],"tags":[]}],"categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://huang-guoliang.github.io/categories/Machine-Learning/"},{"name":"Competition","slug":"Machine-Learning/Competition","permalink":"https://huang-guoliang.github.io/categories/Machine-Learning/Competition/"},{"name":"kdd-cup-2022","slug":"Machine-Learning/Competition/kdd-cup-2022","permalink":"https://huang-guoliang.github.io/categories/Machine-Learning/Competition/kdd-cup-2022/"},{"name":"Mathematics","slug":"Mathematics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/"},{"name":"Statistics","slug":"Mathematics/Statistics","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/"},{"name":"think-bayes","slug":"Mathematics/Statistics/think-bayes","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/think-bayes/"},{"name":"Tools","slug":"Tools","permalink":"https://huang-guoliang.github.io/categories/Tools/"},{"name":"PyTorch","slug":"Tools/PyTorch","permalink":"https://huang-guoliang.github.io/categories/Tools/PyTorch/"},{"name":"seaborn","slug":"Tools/seaborn","permalink":"https://huang-guoliang.github.io/categories/Tools/seaborn/"},{"name":"Cheminformatics","slug":"Cheminformatics","permalink":"https://huang-guoliang.github.io/categories/Cheminformatics/"},{"name":"dl4mm","slug":"Cheminformatics/dl4mm","permalink":"https://huang-guoliang.github.io/categories/Cheminformatics/dl4mm/"},{"name":"naked-stats","slug":"Mathematics/Statistics/naked-stats","permalink":"https://huang-guoliang.github.io/categories/Mathematics/Statistics/naked-stats/"}],"tags":[{"name":"Competition","slug":"Competition","permalink":"https://huang-guoliang.github.io/tags/Competition/"},{"name":"Python","slug":"Python","permalink":"https://huang-guoliang.github.io/tags/Python/"},{"name":"Stats","slug":"Stats","permalink":"https://huang-guoliang.github.io/tags/Stats/"},{"name":"Bayes","slug":"Bayes","permalink":"https://huang-guoliang.github.io/tags/Bayes/"},{"name":"PyTorch","slug":"PyTorch","permalink":"https://huang-guoliang.github.io/tags/PyTorch/"},{"name":"Flask","slug":"Flask","permalink":"https://huang-guoliang.github.io/tags/Flask/"},{"name":"seaborn","slug":"seaborn","permalink":"https://huang-guoliang.github.io/tags/seaborn/"},{"name":"ML","slug":"ML","permalink":"https://huang-guoliang.github.io/tags/ML/"},{"name":"Descriptor","slug":"Descriptor","permalink":"https://huang-guoliang.github.io/tags/Descriptor/"}]}